# MAGIC_VALUES 확장 제안 문서

본 문서는 기존 PoC에서 사용된 `MAGIC_VALUES` 기반 바이트 주입(쉘코드 유래 값)을 CPython JIT 스텐실(`jit_stencils.h`)의 실제 발생 패턴과 정렬하여, 보다 현실적인 가젯(ROP-friendly instruction fragments) 출현 확률을 높이기 위한 확장 전략을 기술한다.

## 1. 현재 사용 중인 쉘코드 파편과 한계

쉘코드 기반 기본 시퀀스 (execve("/bin/sh")):

```
48 31 c0        ; xor rax, rax
bb 2f 2f 62 69  ; mov ebx, 0x69622f2f (하위 4바이트 부분) + 상위(“/bin/sh” 전체는 mov rbx, imm64)
69 6e 2f 73     ; (문자열 잔여 부분, 실제 mov rbx, imm64 내부) 
68              ; push imm8 (문맥에 따라) / 여기서는 push rax 와 구성이 다름
50 53           ; push rax / push rbx
48 89 e7        ; mov rdi, rsp
48 31 f6        ; xor rsi, rsi
48 31 d2        ; xor rdx, rdx
b8 3b 00 00 00  ; mov eax, 59
0f 05           ; syscall
```

JIT 스텐실에서 직접 발견된 것은 `ret (c3)`, `pop reg; ret`, `xor edx, edx (31 d2)` 다수, 그리고 분기/호출(rel32 패치 포인트)류. 그러나 아래는 스텐실에 없음:

- `syscall (0f 05)`
- `mov eax, 59 (b8 3b 00 00 00)`
- 쉘 문자열 관련 즉치(imm64) 패턴 (mov rbx, 0x68732f6e69622f2f) — 템플릿 목적과 무관

따라서 순수 JIT 코드에서 execve 직접 호출 형태를 완성하기 어렵고, syscall 시퀀스는 외부 RWX 영역이나 다른 모듈/라이브러리 가젯으로 대체해야 한다.

## 2. 스텐실에서 관찰된 고빈도 / 유용 패턴 분류

| 분류 | 패턴 | 용도 | 빈도 경향 |
|------|------|------|-----------|
| 종료 | `c3` | ret 가젯 종결 | 매우 많음 (대부분 함수 말단) |
| 레지스터 팝+종결 | `58/59/5a/5b/5d/5e/5f c3` | pop rax/rcx/rdx/rbx/rbp/rsi/rdi; ret | 다수 함수 테일에서 발견 |
| 제로잉 | `31 d2` | xor edx, edx (zero) | 조건 검사 후/분기 주변 다수 |
| (드물게) 제로잉 | `48 31 c0` | xor rax, rax | 상대적으로 적음 |
| 분기 | `0f 84/85 ?? ?? ?? ??` | je/jne rel32 | 템플릿 분기 구조 핵심 |
| 점프 | `e9 ?? ?? ?? ??` | jmp rel32 (continue/error target) | 스택/에러 경로 정리 |
| 호출 | `e8 ?? ?? ?? ??`, `ff 15 00 00 00 00` | call rel32, RIP indirect | 런타임 패치 대상 |

## 3. 확장 MAGIC_VALUES 설계 원칙

1. "길고 특정한 상수" 대신 "짧고 빈번한 명령 바이트" 중심 → JIT가 자연스럽게 재사용하는 구조.
2. 상태 교란(side-effect)이 낮고 체이닝에 유리한 것 우선: `pop rdi; ret`, `pop rsi; ret`, `pop rdx; ret`, `xor edx, edx`, `xor rax, rax`.
3. 스택 기반 체인 구축을 위해 다중 pop 가젯 조합 확보 → 여러 emit 함수 테일 섹션에서 ret 앞의 레지스터 저장 관용 패턴 활용.
4. 분기(rel32) 패턴(`je/jne`)은 직접 가젯화 어려우나 ROP 체인 점프 브리징 시 주소 재계산 후 trampoline 구성 가능.
5. syscall 부재 → 별도 RWX 메모리에 `syscall` 단편 제공하거나 libc 내부 가젯 검색 병행.

## 4. 제안하는 NEW_MAGIC_VALUES 카테고리

### (A) 단일/이중 바이트 명령 패턴
- `c3` (ret)
- `58`, `59`, `5a`, `5b`, `5d`, `5e`, `5f` + 연속 `c3` (pop reg; ret)
- `31 d2` (xor edx, edx)
- `48 31 c0` (xor rax, rax)

이들은 그대로 정수로 인코딩 가능: 예) `0xC3`, `0x5FC3`, `0x5EC3` 등. 길이가 다르므로 관리 구조는 (bytes sequence list).

### (B) 확장적 흐름 제어 참조용 (선택적으로 추출만; 주입은 비권장)
- `0f 84 ?? ?? ?? ??` / `0f 85 ?? ?? ?? ??`
- `e9 ?? ?? ?? ??`
- `e8 ?? ?? ?? ??`

Wildcards 포함 패턴은 주소 종속적이므로 MAGIC_VALUES로 직접 주입 가치 낮음. 단, 정적 스캔 결과 매핑 데이터는 체인 재배열 시 힌트로 활용.

### (C) Fallback 외부 제공 전용
- `0f 05` (syscall)
- `b8 3b 00 00 00` (mov eax, 59)

템플릿에 없으므로 PoC 내 mmap RWX 블록이나 기존 shellcode 조각으로 계속 공급.

## 5. 우선순위 및 점수화 예시

| 패턴 | 체인 가치(High/Med/Low) | 빈도 | 사이드이펙트 | 비고 |
|-------|-------------------------|------|--------------|------|
| pop rdi; ret | High | 중~상 | rdi 로드 | 인자 설정 핵심 |
| pop rsi; ret | High | 중 | rsi 로드 | argv/envp 준비 |
| pop rdx; ret | High | 중 | rdx 로드 | envp/길이 등 |
| xor edx, edx | Med | 상 | edx=0 | 초기화 후 pop 회피 |
| xor rax, rax | Med | 저 | rax=0 | 시스템콜 번호 설정 전 초기화 |
| ret | Low | 상 | 없음 | 슬라이딩/정렬용 필러 |

점수 합산 규칙(예시): 빈도(0~3) + 가치(0~3) - 부작용(0~2). 이를 이용해 주입 후보를 정렬하여 상위 N개만 활용.

## 6. 구현 구조 제안

```python
NEW_MAGIC_VALUES = [
    b"\xc3",               # ret
    b"\x5f\xc3",           # pop rdi; ret
    b"\x5e\xc3",           # pop rsi; ret
    b"\x5a\xc3",           # pop rdx; ret
    b"\x5b\xc3",           # pop rbx; ret (레지스터 임시 저장용)
    b"\x31\xd2",           # xor edx, edx
    b"\x48\x31\xc0",       # xor rax, rax
    # 아래는 fallback 외부공간에서만 제공
    # b"\x0f\x05",         # syscall (외부)
    # b"\xb8\x3b\x00\x00\x00",  # mov eax,59 (외부)
]
```

주입 시나리오는 "패턴 자체"를 만들기보다, JIT가 이런 패턴을 이미 갖고 있음을 활용해 실행 시점에 해당 바이트열 위치를 동적으로 스캔해 체인에 끼워 넣는 형태가 바람직.

## 7. 리스크 / 제약

1. JIT 코드 레이아웃은 CPython 버전, 빌드 옵션(최적화/디버그)에 따라 변동 → 하드코딩 오프셋 금지, 항상 동적 스캔.
2. rel32 분기/호출은 주소 의존적 → 고정 가젯으로 취급하기 어려움.
3. `syscall` 부재로 인해 최종 특권 전환/시스템 호출은 외부 가젯 또는 라이브러리 의존.
4. pop rsp; ret (0x5c 0xc3)는 체인 구조 파괴 가능 → 기본 목록에서 제외.
5. 메모리 오퍼랜드를 갖는 긴 패턴(incq, movabs 등)은 예측 가능성이 떨어져 가젯으로 비추천.

## 7-1. 스텐실에 특정 패턴이 없는 이유 (부재 패턴 의미 해석)

- syscall(0f 05) 부재: CPython JIT 스텐실은 VM 내부 루틴 호출과 분기만 표현한다. 시스템 콜은 런타임 라이브러리 또는 커널 경계를 의미하며, 인터프리터 설계상 직접 배치하지 않는다. 따라서 템플릿에 등장할 이유가 없다.
- mov eax,59(b8 3b 00 00 00) 부재: 시스템 콜 번호 로드를 전제로 하지 않으므로 등장하지 않는다. 또한 스텐실의 호출은 대부분 간접 호출(RIP상대) 또는 rel32 call 패치로 처리된다.
- 대형 즉치/문자열(예: "/bin/sh"용 imm64) 부재: 템플릿은 CPython 내부 심볼 주소/슬롯용 패치(imm64)만 사용하며, 임의 데이터 문자열을 코드에 직접 싣지 않는다. 데이터는 별도 data_body/GOT 역할을 통해 접근한다.
- pop+ret 시퀀스 제한: ret는 함수 말단에 많지만, pop reg; ret 조합은 함수 프롤로그/에필로그 패턴에 종속된다. rdi/rsi/rdx 등 일부는 자연스럽게 등장하나 모든 레지스터가 고르게 나오지는 않는다. pop rsp; ret(스택 파괴)는 안전성 이유로 템플릿에서 드물거나 회피된다.
- xor rax,rax(48 31 c0)가 상대적으로 적은 이유: JIT 경로에서 누산기(rax) 초기화를 강제할 필요가 적고, 상태 설정은 보통 호출 규약에 맞춘 인자 준비(rdi/rsi/rdx)와 태깅/마스크 연산으로 해결되기 때문이다. 반면 edx(zero)는 카운트/플래그/길이 연산 준비로 자주 쓰여 빈도가 높다.

## 8. 확장 적용 절차 (요약)

1. 스텐실 정적 스캐너(`stencil_gadget_scanner.py`) 결과를 JSON/CSV로 덤프(선택 개선).
2. 런타임 JIT 메모리에서 ret 이전 1~8바이트 윈도우 재스캔 → 조합(pop+ret, xor+ret 등) 추출.
3. 추출된 주소 집합 캐시 → PoC 내 ROP 체인 빌더가 필요 레지스터 로딩 순서(pop rdi → pop rsi → pop rdx → 기타)대로 선택.
4. 부족한 요소(syscall 등)는 외부 RWX 스텁 삽입.
5. 실패 대비: 가젯 density 낮으면 fallback shellcode 직접 실행 경로 유지.

## 9. 추후 개선 아이디어

- ret 근처 슬라이딩 윈도우 자동 축약(예: 불필요한 mov/lea 제거 후 최소 시퀀스 식별) → “미니 가젯” 추출.
- 분기 타겟의 직후 영역(패치 포인트 뒤)에서 레지스터 클로버리지 낮은 특정 패턴 수집.
- 통계 기반(빈도/성공률) 가젯 점수 파일 생성 → 다음 실행에서 우선순위 재사용.

## 10. 결론

MAGIC_VALUES는 더 이상 고정된 쉘코드 4바이트 블록을 모방하기보다, JIT 스텐실로부터 자연스럽게 다수 출현하는 짧은 명령 바이트열을 중심으로 재구성해야 한다. 이를 통해 JIT 자체 코드 영역에서 pop/제로잉 기반 ROP 가젯을 직접 수집·활용 가능하며, syscall 같이 부재한 요소는 외부 공급으로 분리하는 하이브리드 전략을 적용한다.

---
문서 버전: v1 (초안)
작성 날짜: 2025-11-11