\documentclass{ieeeaccess}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
% Use draft mode to avoid errors for missing image files; draws placeholders instead
\usepackage{graphicx}
\usepackage{textcomp}
% Improve line breaking and reduce overfull/underfull boxes
\usepackage{microtype}
% Be more lenient with line breaking to avoid small overfull boxes
\emergencystretch=2em
% Code listings with automatic line breaking (replaces long verbatim blocks)
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily\footnotesize,
  breaklines=true,
  breakatwhitespace=true,
  columns=fullflexible,
  keepspaces=true,
  tabsize=2
}
% Encoding to handle UTF-8 input safely in pdflatex
\usepackage[utf8]{inputenc}
\usepackage{xcolor}
\newcommand{\ypkim}[1]{\textcolor{red}{#1}}
\newcommand{\shyoo}[1]{\textcolor{blue}{#1}}

% Note: T1 font encoding can cause font map warnings in some TeX Live setups.
% Use default encoding to reduce font-related warnings in this environment.
% \usepackage[T1]{fontenc}
% Allow better URL line breaking in bibliography and text
\usepackage[hyphens]{url}
\usepackage{comment} % ypkim

\urlstyle{same}
% Initialize figure width macro for ieeeaccess's caption logic when using plain figure environments
\providecommand{\xfigwd}{0pt}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}
\history{Date of publication xxxx 00, 0000, date of current version xxxx 00, 0000.}
\doi{10.1109/ACCESS.2017.DOI}

%\title{Exploiting CPython's Just-In-Time Optimization: \\ Trampoline Hijacking and StencilLeak ROP Attacks}

\title{Exploiting CPython's Just-In-Time Optimization: \ypkim{StencilLeak ROP Attacks}}

\author{\uppercase{First A. Author}\authorrefmark{1}, \IEEEmembership{Fellow, IEEE},
\uppercase{Second B. Author\authorrefmark{2}, and Third C. Author,
Jr}.\authorrefmark{3},
\IEEEmembership{Member, IEEE}}
\address[1]{National Institute of Standards and 
Technology, Boulder, CO 80305 USA (e-mail: author@boulder.nist.gov)}
\address[2]{Department of Physics, Colorado State University, Fort Collins, 
CO 80523 USA (e-mail: author@lamar.colostate.edu)}
\address[3]{Electrical Engineering Department, University of Colorado, Boulder, CO 
80309 USA}
\tfootnote{This paragraph of the first footnote will contain support 
information, including sponsor and financial support acknowledgment. For 
example, ``This work was supported in part by the U.S. Department of 
Commerce under Grant BS123456.''}

\markboth
{Author \headeretal: Preparation of Papers for IEEE TRANSACTIONS and JOURNALS}
{Author \headeretal: Preparation of Papers for IEEE TRANSACTIONS and JOURNALS}

\corresp{Corresponding author: First A. Author (e-mail: author@ boulder.nist.gov).}

\begin{abstract}

This paper presents two exploits that compromise the latest CPython. To boost the performance of Python, the latest CPython employs the Just-In-Time (JIT) optimization as experimental feature. The JIT optimization dynamically translates frequently-executed bytecode into precompiled native code. However, the copy-and-patch mechanism in the JIT optimization relies on writable-then-executable (RW$\to$RX) memory regions and trampoline gadgets, and we uncover potential attack vectors that have not been previously explored. Through a detailed security analysis, we come up with practical exploitation techniques that target the CPython copy-and-patch JIT optimization.

We validate our exploitation techniques under realistic security configurations, including active enforcement of AppArmor and Write XOR Execute (W\textasciicircum X) policies. 
%We show that unauthorized shellcode execution across multiple iterations succeeds reliably on both AArch64 and x86\_64 platforms. 
\ypkim{
We show that unauthorized shellcode execution across multiple iterations succeeds reliably on x86\_64 platforms.}
Also, we show that a \ypkim{return-oriented programming(ROP)} chain can be successfully established on x86\_64. Our analysis reveals that ROP gadgets can be found in the precompiled code templates with good probability, which leads to effective construction of a gadget chain suitable for attacks. 
%Although the JIT optimization is experimental in CPython, considering that Python rapidly grows in AI system deployments and its performance boost is ever needed, the JIT optimization in CPython warrants a rigorous security evaluation. 
Considering that Python rapidly grows in AI system deployments and its performance boost is ever needed, \ypkim{the security evaluation of JIT optimization in CPython is valuable.}
We believe this paper is the first to conduct such an evaluation. \end{abstract}

\begin{keywords}
Python Security, copy-and-patch JIT, CPython, StencilLeak Return-Oriented Programming, Shellcode Injection
\end{keywords}

\titlepgskip=-15pt

\maketitle

\section{Introduction}
\label{sec:introduction}
\PARstart{P}{ython} has become one of the most widely used programming languages, praised for its readability, simplicity, and flexibility across domains. In particular, Python plays a central role in artificial intelligence (AI) research and production, powering frameworks such as TensorFlow~\cite{abadi2016tensorflow}, PyTorch~\cite{paszke2019pytorch}, and scikit-learn~\cite{scikit-learn}. This ubiquity has made Python the de facto language for machine learning, data science, and cloud infrastructure management.

Despite its strengths, Python’s performance has long lagged behind native languages like C++ or Rust. Because Python does interpreter-based execution, it exhibits performance bottlenecks, particularly in tight computational loops such as in neural network training and inference, prompting extensive research into runtime optimization techniques. Optimizations such as Just-In-Time (JIT) compilation have attracted growing interest.

CPython is a popular implementation of Python, and recent CPython 3.13 and 3.14 include a JIT optimization technique called ``copy-and-patch'' as an experimental feature~\cite{cpythonjit, cpythonjit3_13, cpython_pep659}. It dynamically translates Python bytecode into native machine instructions at runtime, offering substantial speedups. Specifically, this JIT optimization uses precompiled machine code templates, known as stencils, which minimize the dynamic code compilation overhead at run-time. Early benchmarks report performance gains of up to 30\% in select workloads~\cite{cpython_jit_benchmark} without requiring a full-fledged dynamic compilation infrastructure. 

However, the introduction of JIT into CPython can significantly alter its threat model. Machine learning inference services deployed in Python often run in multi-user systems such as serverless endpoints or containerized APIs. If a malicious user can exploit the stencils to inject code or redirect control flow, they may also manipulate the AI model’s behavior, extract private training data, or compromise the security of other users’ sessions.

Security concerns surrounding JIT compilation have been known from prior attacks on JavaScript engines and JVMs~\cite{athanasakis2015devil, maisuradze2018jitread}. CPython is known to be a relatively safe runtime due to its interpreter-based execution. With the JIT optimization, we show that the stencil-based code emission influences gadget predictability and exploitation feasibility in CPython. Then we present exploits that emit attack code into the JIT memory region by utilizing JIT spraying~\cite{blazakis2010jit} and just-in-time ROP~\cite{snow2013jitrop}. Although the JIT optimization is experimental in CPython, considering that Python rapidly grows in AI system deployments and its performance boost is ever-needed, the JIT optimization in CPython warrants a rigorous security evaluation. We believe this paper is the first to conduct such an evaluation. 

This paper makes the following contributions:
\begin{itemize}
    \item Demonstrates the trampoline-based shellcode injection attacks in CPython’s copy-and-patch JIT.
%  \item Analyzes the predictability and reproducibility of emitted JIT gadgets across AArch64 and x86\_64 platforms.
  \item \ypkim{Analyzes the predictability and reproducibility of emitted JIT gadgets on x86\_64 platforms.}
    \item Evaluates the ineffectiveness of OS-level security mechanisms such as AppArmor and \ypkim{Address space layout randomization(ASLR)} against our exploits.
    \item Provides practical insights for securing CPython deployment with JIT optimization.
\end{itemize}

%Our experiments reveal that the trampoline-based shellcode execution reliably succeeds by bypassing security policies, achieving a 100\% success rate. 

\ypkim{Our Proof-of-Concept(PoC) Python prototype(\texttt{jit-leak-rop.py}) show that the unexpected shellcode execution reliably succeeds by bypassing security policies.}
Also, we show that an ROP chain can be successfully established with stencil-based copy-and-patch JIT. Our analysis reveals that ROP gadgets can be found in stencil-based precompiled code templates, which leads to effective construction of a gadget chain suitable for attacks.

The remainder of this paper is structured as follows: 
%Section \ref{ch:background} provides the necessary background on CPython’s copy-and-patch JIT compiler, detailing low-level stencil-based code generation on both AArch64 and x86\_64 architectures, along with their associated attack surfaces. 
\ypkim{Section \ref{ch:background} provides the necessary background on CPython’s copy-and-patch JIT compiler, detailing low-level stencil-based code generation on the x86\_64 architecture, along with the associated attack surfaces.}
Section \ref{ch:sec_analysis} presents a comprehensive security analysis including our threat model and potential attack vectors. The experimental methodology underpinning our validation campaign is documented in Section \ref{ch:experiments}. 
%In Section \ref{ch:discussion}, we discuss additional considerations of JIT ROP on AArch64. 
\ypkim{In Section \ref{ch:discussion}, we discuss additional considerations of CPython JIT ROP.}
Section \ref{ch:relatedwork} reviews relevant prior work in the domain of JIT security. Finally, Section \ref{ch:conclusion} concludes the paper by summarizing our contributions and outlining future research directions.


\section{Background}
\label{ch:background}

% \Figure[t!](topskip=0pt, botskip=0pt, midskip=0pt){fig/fig1_tier-2_jit.pdf}
% {Overview of CPython’s Tier-2 JIT processing.\label{fig:tiered-2-jit}}

\begin{figure*}[t!]
\centering
\includegraphics[width=0.8\textwidth]{fig/fig1_tier-2_jit.pdf} % You can replace with actual figure later
\caption{Overview of CPython's Tier-2 JIT processing.}
\label{fig:tiered-2-jit}
\end{figure*}

\subsection{Overview of JIT Optimization}

Python 3.13 introduced the copy-and-patch Just-In-Time (JIT) compilation, marking a significant advancement in Python’s ongoing performance optimization efforts. This JIT compiler relies on precompiled machine code templates, known as ``stencils,'' which contain placeholders (``holes'') to be patched dynamically at runtime. These patches include literals, operand values, and jump addresses tailored specifically for Python bytecode execution paths \cite{cpython_pep659}. 

CPython’s JIT operates under a two-tier execution model: 
\begin{itemize}
\item \textbf{Tier-1 (Interpreter)}: The traditional CPython interpreter profiles to identify frequently executed (``hot”) functions while executing Python bytecode.
\item \textbf{Tier-2 (JIT)}: Once functions are marked as hot, they are promoted to JIT compilation. Their bytecode is first translated into an optimized intermediate representation (IR), comprising micro-operations (``uops”). 
\end{itemize}

Instead of dynamically generating native code from scratch, CPython leverages stencil-based code generation. Stencils are templates resembling standard bytecode handlers. This strategy strikes a balance between performance optimization and code maintainability, significantly reducing the complexity and overhead typically associated with real-time native code generation. 

The complete Tier-2 JIT process consists of the following steps in Figure \ref{fig:tiered-2-jit}:
\begin{enumerate}
\item \textbf{Executor buffer Allocation}: At runtime, the JIT compiler allocates memory regions for the executor buffer using system calls. On macOS, JIT pages may be allocated with \texttt{mmap()} using \texttt{MAP\_JIT}~\cite{macos_map_jit}; on Linux, \texttt{MAP\_JIT} is not available. Pages are typically created writable (RW) for copy-and-patch and later protected as read-execute (RX) to respect W\textasciicircum X. Allocated memory includes space for native code, trampoline stubs, and associated JIT data sections. In this paper, we call the entire executor buffer the JIT region. 
\item \textbf{Stencil Selection and Copying}: Python bytecodes are mapped to predefined stencil groups. The JIT compiler loops through the identified hot bytecodes, inspecting stencils to calculate the required memory space for native code and associated data.
\item \textbf{Code Emission and Patching}: Each stencil’s \texttt{emit()} function copies the template into the allocated memory and dynamically patches placeholders with actual values, such as relative jump offsets, constants, and data references.
%\item \textbf{Trampoline Generation}: If external symbols or runtime helper functions are required, the JIT uses trampolines. Stencil has trampoline for indirect jumps (e.g., \texttt{ldr x8, \#8; br x8}) to absolute 64-bit addresses.
\item \textbf{Trampoline Generation}: If external symbols or runtime helper functions are required, the JIT uses trampolines. Stencil has trampoline for indirect jumps (e.g., \texttt{\ypkim{jmp rax}}) to absolute 64-bit addresses.
\item \textbf{Instruction Cache Flush and Protection}: Once native code and trampolines are emitted, memory regions are marked back read-execute (RX), and the instruction cache is flushed to ensure CPU coherency. The generated machine code becomes active and is invoked through function pointers at run-time.
\end{enumerate}


This structured approach, through predictable and reusable stencil templates, provides substantial runtime efficiency across various computational workloads, offering reported speed improvements of up to 30\%~\cite{cpython_jit_benchmark}. Nonetheless, this design significantly alters Python’s threat model, introducing new security concerns regarding the Stencil-based JIT optimization.


%\subsection{Some Details of CPython JIT}
\subsection{\ypkim{Core functionalities of CPython JIT}}

CPython’s copy-and-patch JIT compiler explicitly manages executable memory regions through careful allocation and protection handling according to its stencil-based emission strategy as follows. The level of detail here is limited to what is needed to understand our exploits.

\subsubsection{Executor Buffer Allocation}
In JIT optimization, native code stencils are stored in precompiled instruction sequences (\texttt{code\_body[]}) along with associated metadata (\texttt{data\_body[]}). During JIT, these stencils are copied into dynamically allocated memory regions. The allocation involves system calls tailored to ensure the memory regions are writable during emission and later executable (W\textasciicircum X). \ypkim{For example, o}n macOS, \texttt{MAP\_JIT} is used for JIT pages~\cite{macos_map_jit}; Linux does not provide \texttt{MAP\_JIT}. A typical sequence is to map pages RW, perform copy-and-patch, then transition to RX with \texttt{mprotect()}:

\begin{lstlisting}
unsigned char *memory = mmap(NULL, size,
  PROT_READ | PROT_WRITE,
  MAP_ANONYMOUS | MAP_PRIVATE /* + MAP_JIT on macOS */,
  -1, 0);
/* ... emit & patch ... */
mprotect(memory, size, PROT_READ | PROT_EXEC);
\end{lstlisting}

\subsubsection{Stencil Selection and Copying}

Next, JIT selects the appropriate stencil for the bytecode in the hot code path. For example, if we have an integer addition on the hot code path,
\texttt{LOAD\_CONST()} and \texttt{BINARY\_OP\_ADD\_INT()} stencils are selected. 
CPython provides 274 stencils for commonly used operations \ypkim{on x86\_64 architecture.} 

\subsubsection{Code Emission and Patching}

% \ypkim{ CODE SHOULD BE CHANGED TO X86 INSTRUCTIONS }
Once the stencil is selected, stencil code and data blocks are copied to the executor buffer. This copy operation is code emission. Each stencil has its own emission function. For example, \texttt{emit\_\_BINARY\_OP\_ADD\_INT()} is the function that emits the template code for an integer addition operation (\texttt{BINARY\_OP\_ADD\_INT}). 
%We present a case for the AArch64 platform for the sake of explanation. Analogous code emission exists for Intel 64 with the x86 instruction set architecture.
% \ypkim{We present a case for the Intel 64 with the x86 instruction set architecture.}
\shyoo{We present a case for the x86\_64 architecture.}

The emitted stencil code begins with a standard function prologue and increases the profiler counter statistics:

\begin{lstlisting}
pushq   %rbp               # store stack frame
movabsq $0x0, %rax         # load _Py_stats
testq   %rax, %rax         # NULL check
je      0x21               # skip if NULL
incq    0x9c958(%rax)      # update stats counter
incq    0x1ce628(%rax)     # update stats counter
\end{lstlisting}

Explicit type checks ensure operands are of the \texttt{PyLong} type, involving bitmasking pointers and comparisons:

\begin{lstlisting}
movq -0x10(%r13), %rbx   # load first operand
movq %rbx, %rdi          # copy operand to rdi
andq $-0x2, %rdi         # get PyObject ptr
movabsq $PyLong_Type, %rcx 
                # load PyLong_Type to rcx
cmpq %rcx, 0x8(%rdi)     
                # compare ob_type is PyLong
jne 0x179                
                # if not PyLong_Type, jump out
\end{lstlisting}

Similarly, another operand is loaded on \texttt{rsi} register, and the code checks the type is PyLong. Finally, \texttt{\_PyLong\_Add} function is invoked as follows:

\begin{lstlisting}
callq   *(%rip)      # indirect jump _PyLong_Add
mov 0x40(%r12), %r13 # result on value stack
test %r13,%r13	     # check result 
je      0x1f4        # jump out if error
\end{lstlisting}

In this process, JITed code should be patched to reference symbols like \texttt{\_Py\_stats, PyLong\_Type, \_PyLong\_Add}. Original stencil emission code has an initialized value filled with zero. At every JIT code emission, \texttt{patch\_64()} function overwrites the correct value on the stencil template, making real jump, reference objects feasible at runtime. 

\subsubsection{Trampoline Generation}

% \ypkim{ CODE SHOULD BE CHANGED TO X86 INSTRUCTIONS }

When JIT patches addresses for runtime helper functions, it uses a specialized code template for putting 64-bit addresses. 
Patch addresses are computed relative to the stencil’s data segment (\texttt{data\_body[]}), which serves as a JIT-managed function pointer table (similar in function to a GOT) for crucial runtime symbols such as \texttt{\_Py\_stats}, \texttt{PyLong\_Type}, \texttt{\_PyLong\_Add}, and error handling routines (\texttt{\_\_assert\_fail}). The precise runtime patching mechanisms involve specialized functions:

\begin{itemize}
\item \texttt{patch\_x86\_64\_32rx}: In-code, RIP-relative to data slot for indirect calls, and data slot holds the corresponding function pointer.
\item \texttt{patch\_32r}: internal or external targets, used for relative branches.
\item \texttt{patch\_64}: directly writes 64-bit absolute values into the data segment.
\end{itemize}

An example of this patching logic includes:

\begin{lstlisting}
// Patches to data segment (function pointer slots):
patch_64(data + 0x320, (uintptr_t)&_PyLong_Add);          
    // Function pointer
patch_64(data + 0x328, (uintptr_t)&__assert_fail);        
    // Function pointer

// Code segment patches:
patch_64(code + 0x3, (uintptr_t)&_Py_stats);   
    // Direct absolute address in code
patch_64(code + 0x2e, (uintptr_t)&PyLong_Type); 
    // Direct absolute address in code

// RIP-relative indirect call through data segment (GOT-like pattern):
patch_x86_64_32rx(code + 0x74, (uintptr_t)data + 0x31c);  
    // Points to data slot
// That data slot at 0x320 contains &_PyLong_Add
\end{lstlisting}

% The patched data\_body[] entry has the exact form of a trampoline gadget, including \texttt{ldr x8, [\#offset]; br x8; target\_addr} sequence.

Stencil has data\_body[] entry as well as code\_body[]. In the code\_body[] array, JITed instructions for the target operation is stored. In the data\_body[] array, relocation for runtime symbols are stored. 

%In fact, along with ASLR (Address space layout randomization), functions can be relocated at runtime. Making an indirect jump to relocated function is using two steps. 
In fact, along with \ypkim{ASLR}, functions can be relocated at runtime. Making an indirect jump to relocated function is using two steps. 
First, the function pointer is loaded in the data\_body†[] array. In the above \ypkim{code}, data + 0x320 is the address in the data\_body array. Then, the code segment 

\subsubsection{Instruction Cache Flush and Protection}

% \ypkim{ CODE SHOULD BE CHANGED TO X86 INSTRUCTIONS }

After stencil emission and dynamic patching, the allocated memory explicitly transitions to a secure executable state (RX), disallowing further modifications to mitigate security risks. This transition involves the \texttt{mprotect()} system call or equivalent, coupled with an instruction cache flush to maintain CPU coherency:

\begin{lstlisting}
__builtin___clear_cache((char *)memory,
                       (char *)memory + size);
mprotect(memory, size, PROT_READ | PROT_EXEC);
\end{lstlisting}

\subsection{Attack Surfaces of Copy-and-patch JIT}

% \ypkim{ CODE SHOULD BE CHANGED TO X86 INSTRUCTIONS }

The introduction of the copy-and-patch JIT optimization in CPython significantly alters its threat model by generating executable memory regions during runtime. The JIT regions introduce specific vulnerabilities due to their characteristics.

CPython's stencil-based code emission attempts to balance the performance of native execution and the security of writable-then-executable memory handling (RW$\to$RX): initially mark writable for dynamic patching and subsequently mark back as read-execute only that provides necessary flexibility while maintaining security constraints.

In this section, we present potential attack surfaces of CPython's Copy-and-patch JIT optimization, including the practical limitations of current protections. 

\begin{enumerate}
\item \textbf{Predictable Emission of Native Code Templates}: The stencil-based JIT approach repeatedly reuses precompiled native code templates stored initially in \texttt{code\_body[]}. This reuse makes the instruction sequences  predictable so that attackers may exploit to embed and execute malicious code via JIT spraying techniques~\cite{blazakis2010jit}.

\item \textbf{Runtime-Patchable Immediates}: Dynamically patched constants and immediate values can be encoded as part of an instruction or an indirect jump target. Patched values may carry sensitive information or be attacker-controlled under certain conditions. This patching process, although integral to the stencil JIT approach, provides potential entry points for injecting attacker-supplied data.

%\item \textbf{Indirect Branching via Trampolines}: JIT-generated trampolines frequently contain indirect branch instructions, typically generated as (\texttt{ldr x8; br x8}) on AArch64. If an attacker manages to control these branches (e.g., by manipulating relevant registers or memory locations), they can redirect execution to attacker-controlled payloads, effectively bypassing traditional execution protections such as Data Execution Prevention (DEP).

\item \textbf{Indirect Branching via Trampolines}: \ypkim{JIT-generated trampolines frequently contain indirect branch instructions.} If an attacker manages to control these branches (e.g., by manipulating relevant registers or memory locations), they can redirect execution to attacker-controlled payloads, effectively bypassing traditional execution protections such as Data Execution Prevention (DEP).

\item \textbf{Availability of ROP Gadgets}: Repeated stencil emission can produce predictable, short instruction sequences or ``gadgets." These gadgets, typically ending with indirect jumps or returns, can be chained to form \ypkim{ROP} attacks, circumventing standard defenses such as \ypkim{ASLR}~\cite{snow2013jitrop}.

\item \textbf{Reversible Memory Protections}: Although CPython explicitly transitions JIT-allocated memory regions from RWX to RX permission after dynamic patching, this mechanism alone may not be sufficient. A process with knowledge of the JIT code memory addresses can invoke system calls like \texttt{mprotect()} to revert the memory permission back to RWX. Such reversible memory protection significantly weakens the security guarantees intended by transitioning permissions from RWX to RX~\cite{aleph1996smashing, blazakis2010jit, Chen2011}.

\end{enumerate}

Given the nature of stencil-generated native code and its frequent reuse across executions, the CPython JIT optimization substantially reduces the entropy relied upon by modern memory protection mechanisms. Thus, while providing notable performance improvements, these attack surfaces must be thoroughly evaluated and mitigated in order to fully utilize the benefits of JIT optimization.

\section{Security Analysis of CPython's Stencil-Based JIT}
\label{ch:sec_analysis}
In this section, we systematically analyze the security implications of CPython’s stencil-based JIT optimization. We begin by defining our threat model and assumptions, followed by detailed examinations of potential attack vectors. We then present combined attack scenarios that illustrate how these attack vectors can be orchestrated to compromise CPython's security.

\subsection{Threat Model}
\textbf{Assets: }
Our analysis depends on the integrity and confidentiality of the CPython runtime environment, particularly the JIT-compiled code regions, internal memory layout, and control-flow behavior. Critical assets include executable memory regions produced by the JIT compiler and runtime interfaces such as \texttt{ctypes}, \texttt{mprotect}, and low-level trampolines.

\textbf{Adversary Capabilities: }
We assume an application-level adversary capable of executing Python bytecode in a user-privileged context. The attacker does not require kernel-level privileges and cannot directly write to CPython binaries or the system’s runtime libraries. However, they can interact with internal executor metadata (e.g., functions that retrieve optimized handlers for bytecode instructions), noting that specific symbol names may vary across CPython versions.

\textbf{Adversary Objectives: }
The attacker's goal is to subvert memory safety and control-flow integrity protections by exploiting vulnerabilities exposed through normal use of CPython. Specific objectives include:
\begin{itemize}
  \item Redirection of control flow through crafted trampolines or gadgets.
  \item Compromise of platform-level protections such as ASLR and DEP.
  \item Execution of arbitrary native code within the Python process.
\end{itemize}

\textbf{Assumptions: }
We assume the target environment is a Linux system with standard defenses enabled, including ASLR, DEP (W\textasciicircum X), and security modules such as AppArmor or SELinux. The underlying operating system and kernel are not compromised.
%JIT functionality is enabled, and untrusted C extensions may be loaded at runtime.
We also assume the normal features of CPython that allow introspection and memory interaction:
\begin{itemize}
  \item Access to the CPython API and ABI from compiled extensions.
  \item Use of \texttt{ctypes} and other foreign function interfaces.
  \item Discoverable memory layout regions associated with JIT-compiled code.
\end{itemize}

\textbf{Out-of-Scope Threats: }
We do not consider threats requiring physical access, kernel compromise, or manipulation of the Python interpreter binary at rest. Side-channel attacks and speculative execution vulnerabilities such as \ypkim{Spectre~\cite{Kocher2018spectre} or Meltdown~\cite{Lipp2018meltdown}} are also out of scope.

\subsection{Potential Attack Vectors}
\subsubsection{JIT Spraying Attacks}
\label{subsec:jitspray}
JIT spraying~\cite{blazakis2010jit} involves embedding attacker-controlled immediate constants directly into the emitted instructions, creating executable memory regions containing malicious instruction sequences or gadgets. Attackers typically select specific numeric constants that, when emitted through JIT compiler, translate into potentially exploitable instructions.

\textbf{Immediate-Based JIT Spraying in CPython:}
CPython's stencil-based copy-and-patch JIT complicates immediate-value-based JIT spraying attacks. Unlike conventional JIT compilers that embed attacker-supplied immediates directly into instruction streams, CPython employs indirect loading mechanisms, loading constants from separate data segments at runtime. Consequently, attackers must seek indirect methods instead of direct malicious instruction embedding.

\subsubsection{StencilLeak}
\label{subsec:reusejitcode}
Historically, attackers have leveraged JIT-generated code to identify gadgets and trampoline patterns, facilitating memory disclosures and control-flow hijacking~\cite{shacham2007geometry}. \ypkim{However,} CPython's stencil-based JIT exacerbates the predictability and portability of emitted gadgets by consistently reusing code templates (stencils) across multiple executions and even distinct CPython processes.  Attackers can reliably predict gadget locations and offsets within the JIT-emitted memory regions. We define a gadget found in the stencil as a \textbf{StencilLeak Gadget}.

\begin{comment}
\subsubsection{Trampoline Hijacking}
\label{subsec:trampoline}
Trampoline exploits involve indirect call or jump instructions to redirect execution flow to attacker-controlled memory locations~\cite{checkoway2010rop}. 
%These typically manifest as indirect jump sequences such as \texttt{ldr x8, [address]; br x8} on AArch64 or \texttt{mov rax, [address]; jmp rax} on x86\_64. 
\ypkim{These typically manifest as indirect jump sequences such as \texttt{mov rax, [address]; jmp rax} on x86\_64.}
CPython’s stencil-based JIT optimization regularly utilizes such trampolines to dynamically resolve addresses for runtime helper functions, introducing potential attack vectors if attackers gain control over the memory references or registers utilized by these instructions.

\textbf{Abusing Trampolines for Control-Flow Hijacking in CPython:}
CPython generates trampoline instructions to resolve addresses of internal runtime functions. If vulnerabilities such as buffer overflows or use-after-free conditions allow attackers to manipulate addresses stored in memory or loaded into registers, these trampolines can serve as mechanisms for redirecting execution flow to attacker-controlled code or shellcode residing in executable memory regions.

\textbf{Direct Trampoline Overwrites as a Path to Code Execution:}
If attackers obtain direct write access to CPython-generated trampoline areas, the complexity involved in finding and chaining gadgets is substantially reduced. Direct trampoline modification allows attackers to overwrite trampoline instructions with arbitrary, simpler jump sequences pointing directly to malicious payloads. Thus, safeguarding trampoline memory against unauthorized modifications is crucial in preventing execution-flow hijacking in CPython's JIT environment.

\end{comment}

\begin{table*}[th!]
\centering
\caption{Summary of CPython JIT-Based Attack Strategies}
\begin{tabular}{|p{0.25\linewidth}|p{0.65\linewidth}|}
\hline
\textbf{Attack Strategy} & \textbf{Description in CPython Context} \\
\hline
JIT Spraying & Attempts to embed attacker-controlled constants into emitted JIT code. CPython’s stencil-based JIT limits direct spraying, but indirect memory operations may still be abused to construct partial gadget-like sequences. \\
%\hline
%Trampoline Hijacking & Targets indirect branch trampolines (e.g., \texttt{br xN}) used in CPython’s JIT dispatch. If memory or pointer-based control is gained, attackers can redirect execution to chosen locations. \\
\hline
StencilLeak ROP & Exploits predictable instruction sequences from reusable stencils. Once the JIT region’s base address is disclosed, attackers can locate and chain gadgets for ROP-style control flow manipulation. \\
\hline
\end{tabular}
\label{tab:attack_summary}
\end{table*}

\subsubsection{StencilLeak ROP}
\label{subsec:jitrop}
Just-In-Time Return-Oriented Programming (JIT-ROP)~\cite{snow2013jitrop} dynamically identifies and chains gadgets located within JIT-generated executable memory regions at runtime. Traditional ROP attacks reuse static code segments such as standard libraries, but JIT-ROP leverages gadgets generated during runtime compilation, exploiting their inherent predictability and consistency.
We discover a new type of JIT-ROP, \textbf{StencilLeak ROP} which is based on chaining StencilLeak gadgets.

\textbf{StencilLeak ROP Gadget:}
We perform the experimental analysis of CPython-generated JIT code and  find  the architecture-specific gadget patterns. 
%On AArch64, typical gadgets include instruction sequences like \texttt{ldr x8, [address]; br x8}, facilitating indirect control-flow redirection. 
\ypkim{On x86\_64,} commonly emitted gadgets involve stack manipulation instructions such as \texttt{pop rdi; ret}, \texttt{pop rsi; ret}, or indirect branching instructions like \texttt{mov rax, [address]; jmp rax}. Attackers exploiting memory disclosure vulnerabilities can dynamically scan JIT memory to discover and chain these gadgets.

\textbf{StencilLeak gadgets offsets: }
We observe that StencilLeak gadgets are predictable due to repetitive and structured operations such as type checks, arithmetic computations, and memory access instructions.
StencilLeak gadgets offsets within JIT-generated memory serve as stable reference points critical for constructing precise exploit chains. This means that the complexity of exploit development is significantly reduced , enabling attackers to reliably compute absolute gadget addresses if they have obtained the JIT region's base address.

\textbf{Undermining ASLR:}
The effectiveness of ASLR is significantly undermined in CPython's JIT environment due to two key factors: the reuse of identical stencil-generated code and the presence of internal memory disclosure APIs. 
%Internal APIs such as \texttt{\_Py\_GetExecutor()} reveal  the critical metadata about JIT-compiled code regions, including base addresses and sizes. 
Internal APIs such as \texttt{\ypkim{get\_executor()}} reveal the critical metadata about JIT-compiled code regions, including base addresses and sizes. 
This disclosure allows attackers to determine the randomized base address directly, simplifying ASLR bypass.


\subsection{Chaining attack vectors}

Exploitation typically involves chaining multiple attack vectors, where the strengths of one vector mitigate the limitations of another, culminating in complex and effective attack sequences. We find that such chaining becomes particularly feasible with the above-mentioned attack vectors in the following stages. 
\ypkim{Note that our attack is an end-to-end attack that begins with a single Python file(\texttt{jit\_leak\_rop.py}) and proceeds through the following stages.}

\textbf{Stage 1. Preparing the Attack Surface via JIT Exposure:}
%A practical exploitation scenario begins with leveraging CPython’s openness to untrusted C extension modules. A crafted C module can leak sensitive information such as the base address of the JIT-compiled executable memory region. Specifically, using internal symbols like \texttt{\_Py\_GetExecutor()} or by inspecting memory mappings via \texttt{/proc/self/maps}, an attacker can determine the location of stencil-generated code. 

A practical exploitation scenario begins with leveraging CPython’s \ypkim{internal API for memory object information. Importing a simple Python package such as \texttt{\_opcode} can leak sensitive information such as the base address of the JIT-compiled executable memory region. Specifically, using internal method like \texttt{get\_executor()}} or by inspecting memory mappings via \texttt{/proc/self/maps}, an attacker can determine the location of stencil-generated code. 

\begin{comment}
\textbf{Stage 2a. Trampoline Hijacking:}
%Next, the attacker targets trampoline instructions—typically indirect branches like \texttt{br x8} on AArch64 or \texttt{jmp rax} on x86\_64—generated by CPython to call the runtime helpers. 
Next, the attacker targets trampoline instructions—typically indirect branches \ypkim{\texttt{jmp rax}} on x86\_64—generated by CPython to call the runtime helpers. 
If the attacker has gained the ability to modify data sections or indirect pointer targets (via buffer overflows, use-after-free, or C extension memory corruption), they can redirect these branches to StencilLeak gadget chains.
\end{comment}

%\textbf{Stage 2b. Gadget Identification via StencilLeak:}
\textbf{Stage \ypkim{2}. Gadget Identification via StencilLeak:}
Once the memory region is identified, the attacker can scan for StencilLeak gadgets—short, usable instruction sequences that are predictably emitted by the stencil-based JIT. 
%These may include control transfer instructions (e.g., \texttt{ret}, \texttt{br xN}) or register manipulations (e.g., \texttt{pop rdi; ret}, \texttt{mov rax, [addr]; jmp rax}). 
These may include control transfer instructions \ypkim{(e.g., \texttt{ret}) or register manipulations (e.g., \texttt{mov rax, [addr]; jmp rax})}. 
The stencil reuse makes the presence and offsets of StencilLeak gadgets available.

\textbf{Stage 3. StencilLeak ROP:}
With gadgets and trampoline redirection mechanisms in place, StencilLeak ROP can be constructed in executable memory. 
%This chain using one of the hijacked trampolines or gadgets pivots the stack or control flow, thereby executing arbitrary logic without injecting traditional shellcode—effectively bypassing DEP/W\textasciicircum X protections.
This \ypkim{gadget chain} pivots the stack or control flow, thereby executing arbitrary logic without injecting traditional shellcode—effectively bypassing DEP/W\textasciicircum X protections.

%This multi-stage exploitation chaining demonstrates how stencil reuse, trampoline constructs, and JIT-generated gadgets converge into a practical attack strategy against CPython. 
This multi-stage exploitation chaining demonstrates how stencil reuse, \ypkim{and} JIT-generated gadgets converge into a practical attack strategy against CPython. 
%Although no single attack vector is fully sufficient, combining attack vectors enables reliable and architecture-agnostic exploitation in the next section.
Although no single attack vector is fully sufficient, combining attack vectors enables reliable \ypkim{exploitation}.
Figure~\ref{fig:attackflow} illustrates the interaction among these components.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.8\linewidth]{fig/Revised_fig_2_v2.png}
  \caption{\ypkim{End-to-end StencilLeak ROP attack flow}}
  \label{fig:attackflow}
\end{figure}

The next section outlines our experimental validation and empirical data collection to quantify the practicality of chaining these attack vectors in CPython.


\section{Experimental Methodology}
\label{ch:experiments}

\subsection{Shared Measurement Framework}

\begin{table}[h!]
\centering
\caption{Proof-of-Concept Platform}
\begin{tabular}{|l|c|}
\hline
\textbf{Property} & \textbf{x86\_64} \\
\hline
Platform & Dell OptiPlex i7-7200 \\
OS & Ubuntu 22.04 \\
Kernel & 5.15 \\
ASLR & Enabled \\
AppArmor & Enforced \\
auditd & Enabled \\
seccomp & Disabled (default) \\
CPython & 3.14 (from source) \\
Privilege level & normal user \\
\hline
\end{tabular}
\label{tab:exp_platform}
\end{table}

To systematically evaluate the security implications of CPython's stencil-based JIT optimization, we developed a comprehensive measurement framework. This framework is designed to facilitate controlled experiments that assess gadget availability, trampoline behavior, and the feasibility of StencilLeak ROP attacks across various scenarios.


\begin{table*}[h!]
\centering
\caption{Static gadget coverage across stencil templates}
\label{tab:stencil_registry_distribution}
\begin{tabular}{|l|c|p{8cm}|}
\hline
\textbf{Gadget / Category} & \textbf{Count (templates)} & \textbf{Remarks} \\
\hline
\texttt{ret} (tail) & 246 & Present in nearly every emit routine \\
\texttt{pop rbx; ret} & 14 & Concentrated in \texttt{BINARY\_OP\_*} stencils (e.g., offset~819) \\
\texttt{pop rdi; ret} & 1 & Only found in \texttt{emit\_shim} \\
\texttt{pop rcx; ret} & 2 & Rare; auxiliary helpers \\
\texttt{xor edx, edx} & 15 & Zeroing helpers for counters/flags \\
\texttt{pop rax; ret} / \texttt{pop rsi; ret} / \texttt{pop rdx; ret} & 0 & Never emitted; prevents fully self-contained chains \\
\texttt{syscall} / \texttt{mov eax, 59} & 0 & Syscall setup delegated to libc or helper stubs \\
\texttt{jmp rel32}, \texttt{jne rel32}, \texttt{je rel32} & $> 1{,}000$ & Abundant indirect control flow \\
\texttt{call rel32} & 180 & Helper dispatch sequences \\
\hline
\end{tabular}
\end{table*}

All experiments run on the x86\_64 platform in Table~\ref{tab:exp_platform} (Ubuntu~22.04, Linux~5.15, CPython~3.14). We trigger Tier-2 JIT by warming each hot function for 6{,}000 iterations (200-iteration chunks) with GC temporarily disabled, then scan the executor buffers with Capstone, \texttt{jitexecleak}, and the Gadget Analysis Framework (generator, scanner, six-class classifier, JSON/CSV reporter). To avoid regenerating code, scenarios A--D are captured once via \texttt{jit\_code\_generator.py}, stored under \texttt{gadget\_analysis/jit\_captures/}, and reloaded by \texttt{jit\_data\_loader.py} in each downstream experiment. Building on this instrumentation, Experiments~1--7 move from the template-only baseline to runtime measurements showing how copy-and-patch and user code patterns cumulatively expand the gadget pool.

\subsection{Experiment 1: Static Analysis of Stencil Templates}

Before examining runtime behavior, we statically decode every \texttt{code\_body[]} entry in \texttt{jit\_stencils.h} using Capstone to quantify what the templates alone provide. This pass builds a baseline catalog of mnemonic frequencies and highlights what is—and is not—available without any runtime patching. Table~\ref{tab:stencil_registry_distribution} summarizes the key findings: 246 of the 275 templates end with a \texttt{ret}, 14 include \texttt{pop rbx; ret}, only one (\texttt{emit\_shim}) exposes \texttt{pop rdi; ret}, and none emit indispensable gadgets such as \texttt{pop rax; ret}, \texttt{pop rsi; ret}, \texttt{pop rdx; ret}, \texttt{syscall}, or \texttt{mov eax, 59}. At the same time, control-flow primitives (\texttt{jmp rel32}, \texttt{jne rel32}, \texttt{je rel32}, \texttt{call rel32}) appear more than a thousand times across the templates. This static baseline highlights that templated emitters naturally produce rich control-transfer sequences and tail \texttt{ret}s but omit the register-pop and syscall gadgets needed for a full ROP chain; these gaps must be filled by other code regions (e.g., libc or helper stubs) once we move beyond template-only analysis.


\paragraph*{User-level pattern impact} Beyond this static view, we crafted Python functions with diverse control-flow motifs to see how user code steers runtime output. Table~\ref{tab:pattern_impact_runtime} shows that multi-argument calls (+55\%), recursion (+30\%), and nested closures (+27\%) markedly increase gadget counts, pointing to register/stack pressure as the dominant factor. Exception-heavy code, \texttt{*args} unpacking, and object attribute access reduce gadget availability, while Python generators (those using \texttt{yield}) never trigger the Tier-2 JIT and thus emit zero gadgets. These observations motivate the high-yield template fed to the JITCodeGenerator (Appendix~\ref{app:jit_template}) so Scenario~A focuses on the richest user-level sequences before we proceed to Experiments~2--7.

\begin{table}[th!]
\centering
\caption{Runtime gadget impact of user-level code patterns (Scenario~A)}
\label{tab:pattern_impact_runtime}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Pattern} & \textbf{Gadgets} & \textbf{vs. Baseline} \\
\hline
Basic loop (baseline) & 33 & -- \\
Multi-argument function calls & 51 & +55\% \\
Nested functions / closures & 42 & +27\% \\
Exception handling-heavy & 23 & $-30$\% \\
Container operations & 35 & +6\% \\
Object attribute access & 6 & $-82$\% \\
Generators (\texttt{yield}) & 0 & $-100$\% (JIT disabled) \\
Unpacking (\texttt{*args}) & 23 & $-30$\% \\
Recursion-heavy & 43 & +30\% \\
Combined high-yield template & 70 & +112\% \\
\hline
\end{tabular}
\end{table}

\paragraph*{JITCodeGenerator setup} The JITCodeGenerator module composes Python functions from these motifs (e.g., multi-argument calls, recursion, nested closures, container-heavy loops) and drives them through a 6{,}000-iteration warmup harness. A representative high-yield template (shown in Appendix~\ref{app:jit_template}) mixes these ingredients to ensure Scenario~A captures include the most gadget-rich configurations a user-crafted script can induce.

\subsection{Experiment 2: Stencil Gadget Catalog}
Building on the template-level catalog, Experiment~1, this experiment quantifies how many gadget types each stencil contributes after dynamic patching. We reuse Scenario~A captures of 100 optimized functions (three repeated runs) that record both pre- and post-patch executor buffers. For each capture we (1) dump \texttt{code\_body[]} and \texttt{data\_body[]} around every \texttt{patch\_*} call, (2) disassemble both snapshots, and (3) classify gadgets via the GadgetClassifier. The resulting dataset (\texttt{experiment\_1\_results/catalog.json}) backs a heat map of stencil IDs versus gadget categories and highlights how runtime patching enriches or shifts the template-level gadget pool.

\textit{Results:} Heat maps and summary tables will be inserted once the offline run finalizes.

\subsection{Experiment 3: Unaligned Decoding}
Because x86\_64 instructions have variable lengths, useful byte patterns can appear even when the decoder starts between “real” instruction boundaries or within freshly patched regions. To quantify this effect, we re-run Capstone with offsets 0--7 on each Scenario~A buffer and tally gadgets before/after patching, normalized by region size. The resulting bar chart (\texttt{offset\_comparison.png}, from \texttt{experiment\_2\_unaligned.py}) highlights which offsets (typically 1 and 2 when bytes include \texttt{0xC3}/\texttt{0xFF}) maximize gadget density.

\textit{Results:} Offset comparison plots and offset-wise statistics will be added once generated.

\subsection{Experiment 4: Patch Function Impact}
This experiment measures how each \texttt{patch\_*} routine changes gadget supply. Still operating on Scenario~A, \texttt{experiment\_3\_patch\_impact.py} matches gadgets across pre/post buffers and attributes each delta to the \texttt{patch\_64}, \texttt{patch\_32}, or \texttt{patch\_x86\_64\_32rx} invocation that touched the bytes. The planned outputs are a scatter plot of patch offsets vs.~new gadget counts and a table of the most impactful stencils.

\textit{Results:} Scatter plots and ranked tables will replace this placeholder after the batch analysis completes.

\subsection{Experiment 5: Executor Memory Scaling}
This experiment examines how gadget counts grow as more executor regions are allocated. Scenario~B emits 1, 8, 16, 32, 64, and 80 executor regions (each 128~KB) via the spread-allocation generator. We regress gadget counts against the number of regions and report 95\% confidence intervals, violin plots per scale point, and per-region densities. The figure set (\texttt{experiment\_4\_results/scaling\_plot.png} and \texttt{violin\_plot.png}) will populate this subsection as soon as the captures are processed.

\textit{Results:} Regression statistics and violin plots will be inserted once Scenario~B processing finishes.

\subsection{Experiment 6: Ret-Free Syscall Taxonomy}
This experiment characterizes the availability of ret-free syscall chains inside JIT code. Scenario~C focuses on syscall-capable pools (50 functions) to evaluate ret-free chains. \texttt{experiment\_5\_syscall\_taxonomy.py} classifies every gadget into \{ret, syscall, indirect branch, stack pivot, pop sequence\} and checks whether the collected syscall gadgets plus pop sequences suffice to invoke \texttt{execve} without trailing \texttt{ret}. We will include the stacked bar chart (\texttt{taxonomy\_chart.png}) and the accompanying ret-free feasibility report once available.

\textit{Results:} Taxonomy charts and ret-free analysis text will be added after Scenario~C runs.

\subsection{Experiment 7: Opcode-Sensitive Generator}
This experiment evaluates how opcode-biased templates affect gadget density. Scenario~D applies the \texttt{spray\_execve} template to bias emitted bytes toward \texttt{0xC3}, \texttt{0x0F05}, and \texttt{0xFF}. \texttt{experiment\_6\_opcode\_sensitive.py} compares the resulting gadget counts and byte histograms against Scenario~A. The improvement summary (\texttt{gadget\_improvement.txt}) and distribution plot will be added here to quantify how much the optimized template outperforms the baseline.

\textit{Results:} Gadget-improvement tables and byte-distribution plots will be inserted when Scenario~D processing completes.

\textit{All figures/tables referenced above are pending automation runs; the surrounding text documents both the objective and the methodology so that, once the data is exported, only the numerical summaries and graphics need to be inserted.}

\section{Discussion}
\label{ch:discussion}

%\ypkim{REMOVED!}

\subsubsection{\ypkim{Attack generality}}
\ypkim{The fundamental security challenge posed by CPython's experimental JIT is rooted in its core design mechanism, which relies on the reuse of predictable, precompiled code templates known as stencils. This design necessitates the dynamic allocation and manipulation of writable-then-executable (RW$\to$ RX) memory regions. We assert that this stencil-based, copy-and-patch approach represents an architecture-agnostic design flaw that fundamentally alters CPython’s threat model.}
\ypkim{The demonstration of StencilLeak ROP attack on x86\_64, achieving shellcode execution, validates the universal exploitability arising from this mechanism. This attack leveraged the JIT’s inherent use of indirect branching via trampolines and the capability to revert memory protections. This success confirms that the predictability of the memory layout, coupled with dynamic permission changes inherent to the copy-and-patch process, provides a reliable control redirection vector regardless of the complexity required for advanced ROP chain assembly.}

\subsubsection{\ypkim{Considerations for attack preconditions}}
%\ypkim{The reliable success of both Trampoline Hijacking (shellcode execution) and StencilLeak ROP is contingent upon the attacker’s ability to successfully defeat two core OS-level memory protections: Address Space Layout Randomization (ASLR) and Write XOR Execute (W\textasciicircum X). Pinpointing the exact preconditions necessary for achieving reliable exploitation represents a significant positive contribution to defense planning, offering clear targets for robust security enhancements.}
\ypkim{The reliable success of StencilLeak ROP is contingent upon the attacker’s ability to successfully defeat two core OS-level memory protections: ASLR and W\textasciicircum X. Pinpointing the exact preconditions necessary for achieving reliable exploitation represents a significant positive contribution to defense planning, offering clear targets for robust security enhancements.}

\ypkim{\textbf{ASLR Bypass as a Foundation:} ASLR is designed to randomize memory locations, but its effectiveness is severely curtailed in the CPython JIT environment due to internal memory disclosure mechanisms. To construct ROP chains or target specific trampolines, attackers must obtain the base address of the JIT region. Our research highlights that internal APIs, such as \texttt{get\_executor()} (or similar metadata access points), or inspection of \texttt{/proc/self/maps}, provide a reliable path to determining this randomized base address. This knowledge empowers developers to prioritize sealing these internal disclosure vectors, thereby restoring ASLR’s defensive value against JIT-based attacks.}

\ypkim{\textbf{W\textasciicircum X Bypass via Reversible Protection:} CPython’s security model depends on transitioning memory permissions from writable/executable (RWX) to read/execute (RX) using \texttt{mprotect()}. However, this transition is reversible. Our successful exploitation, which required making the JIT memory region writable and executable via system calls, demonstrates that the underlying OS mechanism intended to enforce W\textasciicircum X is insufficient if the running process can simply invoke \texttt{mprotect()} to reverse the protection.}

\subsubsection{\ypkim{Vulnerability disclosure plan}}
\ypkim{We notified the Python Security Team in March 2025 of our findings and received formal approval of our coordinated disclosure plan. To minimise risk to end users, technical details and proof-of-concept exploit code have been withheld pending remediation; the Python Security Team will determine the timing and scope of public release. We will continue to coordinate with the Security Team after peer review to ensure patches are tested and deployed before full disclosure. This coordinated approach follows responsible-disclosure best practices and aims to balance transparency with the need to prevent premature exploitation.}


% In this section, we discuss additional considerations for applying JIT ROP on the AArch64 platform. On the AArch64 platform, we also tried to construct a ROP chain. Although our experiments demonstrated that CPython's copy-and-patch JIT emits trampoline gadgets such as \texttt{ldr x8, [\#offset]; br x8}, the construction of meaningful ROP gadget chains was not successful. 

% Here are some of the reasons: 
% \begin{itemize}
  % \item \textbf{Insensitivity to magic values:} The JIT engine emits code based on predefined, statically compiled templates, leading to highly deterministic native code sequences regardless of the input constants.
  % \item \textbf{Small JIT region size:} Each hot function typically emits small sized JIT code, limiting the size of the gadget pool available in a single region. Note that CPython stops using JIT when the code has a complex structure, such as nested conditions or exception handling. 
  % \item \textbf{Low gadget diversity:} In AArch64, trampoline gadgets are commonly used in stencils; however, no other useful gadgets are found in the generated JIT region. A reason is that AArch64's ISA has a rigid length and format in bit encoding. All instructions are 4 bytes, and we cannot use byte patterns appearing in the middle of an instruction, unlike x86\_64.
  % Also, the stencil code rarely emits stack-manipulating instructions such as \texttt{pop}, \texttt{ldr sp}, or \texttt{mov sp, xN}, leading return-based control difficult.
  % \item \textbf{Register constraints:} Most stencil handlers preserve or overwrite key registers used for trampoline chaining, and there are no gadgets to safely load attacker-controlled values into \texttt{x16} or \texttt{x8}.
% \end{itemize}

% Therefore, although trampoline hijacking to shellcode is successful, constructing ROP gadget chains on AArch64 remains infeasible in CPython's current JIT design.

% On some recent AArch64 platforms, Branch Target Identification (BTI) and Pointer Authentication Codes (PAC) may restrict indirect jumps in JIT code, which makes attacks much more difficult~\cite{BtiArm64, Liljestrand2019, PACMacOS}. 

% Yet, restricting all indirect jumps is too rigid; some OSes define a \texttt{MAP\_JIT} flag~\cite{macos_map_jit} in \texttt{mmap()}, which allows writable and executable memory allocation in application memory. 

\section{Related Work}
\label{ch:relatedwork}

In this section, we review prior studies relevant to the security of \ypkim{JIT} compilers, with a particular focus on threats and mitigations applicable to CPython’s experimental copy-and-patch JIT. We categorize the literature as follows:

\subsection{JIT Spraying and Code Injection Techniques}
Blazakis~\cite{Blazakis2010} first introduced JIT spraying as a means to inject executable code by influencing constant emission in JIT-generated machine code. Lian et al.~\cite{Lian2015} extended this technique to ARM architectures, demonstrating gadget chaining attacks in WebKit. Chen et al.~\cite{Chen2011} proposed \textit{JITDefender}, a runtime monitoring system for detecting JIT spraying by analyzing code emission patterns.

\subsection{Return-Oriented Programming (ROP) and Memory Safety Attacks}
Checkoway and Shacham~\cite{Checkoway2010} pioneered ROP and jump-oriented programming techniques that bypass DEP using code reuse. Snow et al.~\cite{Snow2013} developed Just-In-Time ROP (JIT-ROP), showing attackers could dynamically discover and exploit gadgets. Athanasakis et al.~\cite{Athanasakis2015} further demonstrated that JIT engines could be abused to emit ROP gadgets on-demand, while Maisuradze et al.~\cite{Maisuradze2016} examined how execute-only memory only partially mitigates such threats.

\subsection{Trampoline Shellcode and Control Redirection}
Bletsch et al.~\cite{Bletsch2011} introduced JOP, utilizing dispatcher loops and indirect jumps as trampolines. Checkoway et al.~\cite{Checkoway2010} showed how return-less programming could form functional shellcode chains using call-preceded gadgets. These methods underpin trampoline-based control redirection threats in JIT-emitted native code, especially on architectures like ARM, where branch-based control flow is common.

\subsection{Security of JIT Compilers in Dynamic Language Runtimes}
Recent work on CPython 3.13/3.14's copy-and-patch JIT~\cite{Xu2021} notes the security tradeoffs inherent in using patchable templates for runtime code generation. Related efforts include MesaPy~\cite{Wang2018}, which embeds memory safety into a Python JIT through safe languages. JavaScript JITs such as V8 and SpiderMonkey have historically been targets of numerous exploits due to type confusion and optimization flaws~\cite{Athanasakis2015}. JITs in JVM and LLVM have also been evaluated for vulnerability to sandbox escapes~\cite{Payer2012}.

\subsection{Defense Mechanisms: CFI, W\textasciicircum X, and PAC/BTI}
Numerous works propose defense mechanisms for JIT environments. Control-Flow Integrity (CFI)~\cite{Abadi2005}, RockJIT~\cite{Niu2014}, and JITSafe~\cite{Chen2013} enforce control-flow constraints in JIT-generated code. Constant blinding and alignment-based hardening have been proposed~\cite{Jauernig2014}, while hardware-assisted protections like ARM’s PAC and BTI~\cite{Liljestrand2019} offer strong mitigation against ROP/JOP in modern CPUs.

\subsection{JIT Security Testing and Fuzzing Tools}
LangFuzz~\cite{Holler2012} and Fuzzilli~\cite{Gross2023} represent grammar-based fuzzers tailored to dynamic language runtimes. DIE~\cite{Chen2019} and FuzzJIT~\cite{Wang2023} apply differential fuzzing and semantic validation to trigger JIT-specific bugs and validate correctness. These tools can be adapted to evaluate security and reliability of CPython's copy-and-patch JIT.

\section{Conclusion and Future Work}
\label{ch:conclusion}
In conclusion, our research identifies critical vulnerabilities within CPython's \ypkim{c}opy-and-patch JIT compiler, demonstrating practical attack scenarios such as JIT spraying, trampoline-based shellcode injection, and ROP gadget exploitation. Future research directions include further investigation into sandboxing and isolation techniques for JIT-generated code and more comprehensive hardware-assisted security integrations. Additional studies focusing on automated detection and remediation of JIT compiler vulnerabilities will also enhance the robustness of CPython's runtime environment.

\bibliographystyle{IEEEtran}
\bibliography{references}

\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{a1.png}}]{First A. Author} (M'76--SM'81--F'87) and all authors may include 
biographies. Biographies are often not included in conference-related
papers. This author became a Member (M) of IEEE in 1976, a Senior
Member (SM) in 1981, and a Fellow (F) in 1987. The first paragraph may
contain a place and/or date of birth (list place, then date). Next,
the author's educational background is listed. The degrees should be
listed with type of degree in what field, which institution, city,
state, and country, and year the degree was earned. The author's major
field of study should be lower-cased. 

The second paragraph uses the pronoun of the person (he or she) and not the 
author's last name. It lists military and work experience, including summer 
and fellowship jobs. Job titles are capitalized. The current job must have a 
location; previous positions may be listed 
without one. Information concerning previous publications may be included. 
Try not to list more than three books or published articles. The format for 
listing publishers of a book within the biography is: title of book 
(publisher name, year) similar to a reference. Current and previous research 
interests end the paragraph. The third paragraph begins with the author's 
title and last name (e.g., Dr.\ Smith, Prof.\ Jones, Mr.\ Kajor, Ms.\ Hunter). 
List any memberships in professional societies other than the IEEE. Finally, 
list any awards and work for IEEE committees and publications. If a 
photograph is provided, it should be of good quality, and 
professional-looking. Following are two examples of an author's biography.
\end{IEEEbiography}

\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{a2.png}}]{Second B. Author} was born in Greenwich Village, New York, NY, USA in 
1977. He received the B.S. and M.S. degrees in aerospace engineering from 
the University of Virginia, Charlottesville, in 2001 and the Ph.D. degree in 
mechanical engineering from Drexel University, Philadelphia, PA, in 2008.

From 2001 to 2004, he was a Research Assistant with the Princeton Plasma 
Physics Laboratory. Since 2009, he has been an Assistant Professor with the 
Mechanical Engineering Department, Texas A{\&}M University, College Station. 
He is the author of three books, more than 150 articles, and more than 70 
inventions. His research interests include high-pressure and high-density 
nonthermal plasma discharge processes and applications, microscale plasma 
discharges, discharges in liquids, spectroscopic diagnostics, plasma 
propulsion, and innovation plasma applications. He is an Associate Editor of 
the journal \emph{Earth, Moon, Planets}, and holds two patents. 

Dr. Author was a recipient of the International Association of Geomagnetism 
and Aeronomy Young Scientist Award for Excellence in 2008, and the IEEE 
Electromagnetic Compatibility Society Best Symposium Paper Award in 2011. 
\end{IEEEbiography}

\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{a3.png}}]{Third C. Author, Jr.} (M'87) received the B.S. degree in mechanical 
engineering from National Chung Cheng University, Chiayi, Taiwan, in 2004 
and the M.S. degree in mechanical engineering from National Tsing Hua 
University, Hsinchu, Taiwan, in 2006. He is currently pursuing the Ph.D. 
degree in mechanical engineering at Texas A{\&}M University, College 
Station, TX, USA.

From 2008 to 2009, he was a Research Assistant with the Institute of 
Physics, Academia Sinica, Tapei, Taiwan. His research interest includes the 
development of surface processing and biological/medical treatment 
techniques using nonthermal atmospheric pressure plasmas, fundamental study 
of plasma sources, and fabrication of micro- or nanostructured surfaces. 

Mr. Author's awards and honors include the Frew Fellowship (Australian 
Academy of Science), the I. I. Rabi Prize (APS), the European Frequency and 
Time Forum Award, the Carl Zeiss Research Award, the William F. Meggers 
Award and the Adolph Lomb Medal (OSA).
\end{IEEEbiography}

\appendix
\input{appendix_jit_code}

\EOD

\end{document}
\paragraph*{JITCodeGenerator setup} The JITCodeGenerator module composes Python functions from these motifs (e.g., multi-argument calls, recursion, nested closures, container-heavy loops) and drives them through a 6{,}000-iteration warmup harness. A representative high-yield template (shown in Appendix~\ref{app:jit_template}) mixes these ingredients to ensure Scenario~A captures include the most gadget-rich configurations a user-crafted script can induce.
