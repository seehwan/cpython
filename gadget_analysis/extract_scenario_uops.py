#!/usr/bin/env python3.12
"""
Extract actual uops used in Scenario A execution

This script re-runs Scenario A functions and captures the exact uops
that the JIT compiler generates by analyzing bytecode and mapping to Tier-2 uops.
"""

import sys
import os
import pickle
import dis
from collections import Counter, defaultdict

# Add parent directory to path
sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))

# Import generator directly
from gadget_analysis.generator import JITFunctionGenerator

def generate_optimized_jit_function(func_id, complexity='medium', operations=None, use_builtins=True):
    """
    Wrapper function to generate JIT function compatible with Scenario A
    """
    gen = JITFunctionGenerator(use_optimizer=True, stencil_json_path='register_control_gadgets.json')
    func = gen._create_jit_function(func_id)
    return func

def analyze_bytecode_to_uops():
    """
    Generate Scenario A functions and analyze their bytecode to determine
    which Tier-2 uops would be generated by the JIT compiler.
    """
    print("=== Analyzing Scenario A uop Usage ===\n")
    print("Generating 100 functions with 6000-iteration warmup (same as Scenario A)")
    print("This will take several minutes...\n")
    
    function_count = 100
    warmup_iterations = 6000
    
    # Generate all functions (same as Scenario A)
    functions = []
    print("Step 1: Generating functions...")
    for i in range(function_count):
        if (i + 1) % 20 == 0:
            print(f"  Generated {i+1}/{function_count} functions...")
        
        func = generate_optimized_jit_function(
            func_id=i,
            complexity='medium',
            operations=['arithmetic', 'logic', 'control'],
            use_builtins=True
        )
        functions.append(func)
    
    print(f"✓ Generated {len(functions)} functions\n")
    
    # Warm up functions to trigger JIT (same as Scenario A)
    print(f"Step 2: Warming up functions ({warmup_iterations} iterations each)...")
    for i, func in enumerate(functions):
        if (i + 1) % 20 == 0:
            print(f"  Warmed up {i+1}/{function_count} functions...")
        
        for _ in range(warmup_iterations):
            try:
                func()
            except:
                pass
    
    print(f"✓ Completed warmup\n")
    
    # Analyze bytecode opcodes
    print("Step 3: Analyzing bytecode opcodes...")
    bytecode_counter = Counter()
    
    for func in functions:
        for instruction in dis.get_instructions(func):
            bytecode_counter[instruction.opname] += 1
    
    print(f"✓ Found {len(bytecode_counter)} unique bytecode opcodes")
    print(f"✓ Total instructions: {sum(bytecode_counter.values())}\n")
    
    # Display bytecode statistics
    print(f"=== Bytecode Opcode Statistics ===\n")
    print(f"{'Opcode':30} | {'Count':10} | {'%':7}")
    print("-" * 58)
    
    total = sum(bytecode_counter.values())
    for opname, count in bytecode_counter.most_common(40):
        percentage = 100 * count / total
        print(f"{opname:30} | {count:10} | {percentage:6.2f}%")
    
    if len(bytecode_counter) > 40:
        print(f"\n... ({len(bytecode_counter) - 40} more opcodes)")
    
    # Map bytecode to Tier-2 uops based on CPython 3.14 optimizer
    # This mapping is derived from Python/optimizer.c and executor_cases.c.h
    print(f"\n\n=== Mapping to Tier-2 uops ===\n")
    
    bytecode_to_uops_map = {
        'RESUME': ['_START_EXECUTOR', '_RESUME_CHECK'],
        'LOAD_FAST': ['_LOAD_FAST', '_LOAD_FAST_CHECK'],
        'LOAD_FAST_LOAD_FAST': ['_LOAD_FAST', '_LOAD_FAST'],
        'STORE_FAST': ['_STORE_FAST'],
        'STORE_FAST_STORE_FAST': ['_STORE_FAST', '_STORE_FAST'],
        'LOAD_CONST': ['_LOAD_CONST'],
        'LOAD_CONST_LOAD_FAST': ['_LOAD_CONST', '_LOAD_FAST'],
        'BINARY_OP': ['_GUARD_BOTH_INT', '_BINARY_OP_ADD_INT', '_BINARY_OP_MULTIPLY_INT',
                      '_BINARY_OP_SUBTRACT_INT', '_GUARD_BOTH_FLOAT', '_BINARY_OP_ADD_FLOAT',
                      '_BINARY_OP_MULTIPLY_FLOAT', '_BINARY_OP'],
        'BINARY_OP_ADD_INT': ['_GUARD_BOTH_INT', '_BINARY_OP_ADD_INT'],
        'BINARY_OP_MULTIPLY_INT': ['_GUARD_BOTH_INT', '_BINARY_OP_MULTIPLY_INT'],
        'BINARY_OP_SUBTRACT_INT': ['_GUARD_BOTH_INT', '_BINARY_OP_SUBTRACT_INT'],
        'BINARY_OP_ADD_FLOAT': ['_GUARD_BOTH_FLOAT', '_BINARY_OP_ADD_FLOAT'],
        'BINARY_SUBSCR': ['_BINARY_SUBSCR', '_BINARY_SUBSCR_LIST_INT', '_BINARY_SUBSCR_TUPLE_INT',
                          '_BINARY_SUBSCR_DICT', '_BINARY_SUBSCR_STR_INT'],
        'STORE_SUBSCR': ['_STORE_SUBSCR', '_STORE_SUBSCR_LIST_INT', '_STORE_SUBSCR_DICT'],
        'COMPARE_OP': ['_COMPARE_OP_INT', '_COMPARE_OP_FLOAT', '_COMPARE_OP_STR', '_COMPARE_OP'],
        'COMPARE_OP_INT': ['_COMPARE_OP_INT'],
        'COMPARE_OP_FLOAT': ['_COMPARE_OP_FLOAT'],
        'COMPARE_OP_STR': ['_COMPARE_OP_STR'],
        'POP_JUMP_IF_FALSE': ['_POP_JUMP_IF_FALSE', '_GUARD_IS_FALSE_POP', '_SIDE_EXIT'],
        'POP_JUMP_IF_TRUE': ['_POP_JUMP_IF_TRUE', '_GUARD_IS_TRUE_POP', '_SIDE_EXIT'],
        'POP_JUMP_IF_NOT_NONE': ['_POP_JUMP_IF_NOT_NONE'],
        'POP_JUMP_IF_NONE': ['_POP_JUMP_IF_NONE'],
        'JUMP_BACKWARD': ['_JUMP_TO_TOP'],
        'JUMP_FORWARD': ['_JUMP_FORWARD'],
        'LOAD_GLOBAL': ['_LOAD_GLOBAL', '_LOAD_GLOBAL_MODULE', '_LOAD_GLOBAL_BUILTINS'],
        'LOAD_GLOBAL_MODULE': ['_LOAD_GLOBAL_MODULE'],
        'LOAD_GLOBAL_BUILTINS': ['_LOAD_GLOBAL_BUILTINS'],
        'LOAD_ATTR': ['_CHECK_ATTR_MODULE', '_LOAD_ATTR', '_LOAD_ATTR_INSTANCE_VALUE',
                      '_LOAD_ATTR_MODULE', '_LOAD_ATTR_WITH_HINT', '_LOAD_ATTR_SLOT',
                      '_LOAD_ATTR_CLASS', '_LOAD_ATTR_METHOD_WITH_VALUES',
                      '_LOAD_ATTR_METHOD_NO_DICT', '_LOAD_ATTR_METHOD_LAZY_DICT'],
        'STORE_ATTR': ['_STORE_ATTR', '_STORE_ATTR_INSTANCE_VALUE', '_STORE_ATTR_SLOT',
                       '_STORE_ATTR_WITH_HINT'],
        'CALL': ['_CHECK_PERIODIC', '_CHECK_CALL_BOUND_METHOD_EXACT_ARGS',
                 '_CHECK_PEP_523', '_CHECK_FUNCTION_VERSION', '_CHECK_METHOD_VERSION',
                 '_CALL', '_CALL_BUILTIN_CLASS', '_CALL_BUILTIN_O', '_CALL_BUILTIN_FAST',
                 '_CALL_BUILTIN_FAST_WITH_KEYWORDS', '_CALL_LEN', '_CALL_ISINSTANCE',
                 '_CALL_METHOD_DESCRIPTOR_O', '_CALL_METHOD_DESCRIPTOR_FAST',
                 '_CALL_METHOD_DESCRIPTOR_FAST_WITH_KEYWORDS', '_CALL_METHOD_DESCRIPTOR_NOARGS',
                 '_CALL_TYPE_1', '_CALL_STR_1', '_CALL_TUPLE_1', '_CALL_ALLOC_AND_ENTER_INIT'],
        'CALL_BUILTIN_FAST': ['_CALL_BUILTIN_FAST'],
        'CALL_BUILTIN_O': ['_CALL_BUILTIN_O'],
        'CALL_LEN': ['_CALL_LEN'],
        'CALL_ISINSTANCE': ['_CALL_ISINSTANCE'],
        'RETURN_VALUE': ['_RETURN_VALUE'],
        'RETURN_CONST': ['_RETURN_VALUE'],
        'GET_ITER': ['_GET_ITER'],
        'FOR_ITER': ['_FOR_ITER', '_FOR_ITER_LIST', '_FOR_ITER_TUPLE', '_FOR_ITER_RANGE',
                     '_FOR_ITER_GEN'],
        'FOR_ITER_LIST': ['_FOR_ITER_LIST'],
        'FOR_ITER_TUPLE': ['_FOR_ITER_TUPLE'],
        'FOR_ITER_RANGE': ['_FOR_ITER_RANGE'],
        'UNPACK_SEQUENCE': ['_UNPACK_SEQUENCE', '_UNPACK_SEQUENCE_TWO_TUPLE',
                           '_UNPACK_SEQUENCE_TUPLE', '_UNPACK_SEQUENCE_LIST'],
        'BUILD_TUPLE': ['_BUILD_TUPLE'],
        'BUILD_LIST': ['_BUILD_LIST'],
        'BUILD_SET': ['_BUILD_SET'],
        'BUILD_MAP': ['_BUILD_MAP'],
        'LIST_APPEND': ['_LIST_APPEND'],
        'SET_ADD': ['_SET_ADD'],
        'MAP_ADD': ['_MAP_ADD'],
        'CONTAINS_OP': ['_CONTAINS_OP'],
        'IS_OP': ['_IS_OP'],
        'UNARY_NOT': ['_UNARY_NOT'],
        'UNARY_NEGATIVE': ['_UNARY_NEGATIVE'],
        'UNARY_INVERT': ['_UNARY_INVERT'],
        'TO_BOOL': ['_TO_BOOL', '_TO_BOOL_BOOL', '_TO_BOOL_INT', '_TO_BOOL_LIST',
                    '_TO_BOOL_NONE', '_TO_BOOL_STR'],
        'TO_BOOL_BOOL': ['_TO_BOOL_BOOL'],
        'TO_BOOL_INT': ['_TO_BOOL_INT'],
        'TO_BOOL_LIST': ['_TO_BOOL_LIST'],
        'TO_BOOL_NONE': ['_TO_BOOL_NONE'],
        'TO_BOOL_STR': ['_TO_BOOL_STR'],
        'PUSH_NULL': ['_PUSH_NULL'],
        'POP_TOP': ['_POP_TOP'],
        'NOP': ['_NOP'],
        'SWAP': ['_SWAP'],
        'COPY': ['_COPY'],
    }
    
    # Count estimated uops
    uop_counter = Counter()
    bytecode_to_uop_details = defaultdict(lambda: defaultdict(int))
    
    for bytecode, count in bytecode_counter.items():
        if bytecode in bytecode_to_uops_map:
            uops = bytecode_to_uops_map[bytecode]
            # Use the primary/most common uop for this bytecode
            primary_uop = uops[0]
            uop_counter[primary_uop] += count
            
            # Record the mapping details
            for uop in uops:
                bytecode_to_uop_details[bytecode][uop] = count // len(uops)
    
    # Display uop statistics
    print(f"Estimated {len(uop_counter)} unique Tier-2 uops used\n")
    print(f"{'Tier-2 uop':50} | {'Est. Count':12} | {'%':7}")
    print("-" * 80)
    
    total_uops = sum(uop_counter.values())
    for uop, count in uop_counter.most_common(50):
        percentage = 100 * count / total_uops if total_uops > 0 else 0
        print(f"{uop:50} | {count:12} | {percentage:6.2f}%")
    
    if len(uop_counter) > 50:
        print(f"\n... ({len(uop_counter) - 50} more uops)")
    
    # Save results
    results = {
        'method': 'bytecode_to_uop_mapping',
        'function_count': function_count,
        'warmup_iterations': warmup_iterations,
        'bytecode_opcodes': dict(bytecode_counter),
        'estimated_uops': dict(uop_counter),
        'bytecode_to_uop_mapping': {k: dict(v) for k, v in bytecode_to_uop_details.items()},
        'total_bytecode_instructions': total,
        'total_estimated_uops': total_uops,
        'unique_bytecodes': len(bytecode_counter),
        'unique_uops': len(uop_counter)
    }
    
    output_file = 'scenario_a_uop_analysis.pkl'
    with open(output_file, 'wb') as f:
        pickle.dump(results, f)
    
    print(f"\n\n✓ Analysis complete!")
    print(f"✓ Results saved to {output_file}")
    
    return results

if __name__ == '__main__':
    results = analyze_bytecode_to_uops()
    
    # Summary
    print(f"\n{'='*80}")
    print(f"SUMMARY")
    print(f"{'='*80}")
    print(f"Functions analyzed: {results['function_count']}")
    print(f"Warmup iterations: {results['warmup_iterations']}")
    print(f"Unique bytecode opcodes: {results['unique_bytecodes']}")
    print(f"Total bytecode instructions: {results['total_bytecode_instructions']:,}")
    print(f"Estimated unique Tier-2 uops: {results['unique_uops']}")
    print(f"Estimated total uop instances: {results['total_estimated_uops']:,}")
    print(f"{'='*80}\n")
